---
title: 4. Goæ³›å‹
date: 2022-07-07 03:00:00
permalink: /pages/ed80cc/
categories:
    - Go
    - Go è¿›é˜¶
tags:
    -
author:
    name: brook-w
    link: https://github.com/brook-w
---

## ç®€è¿°

Go çš„æ³›å‹æ”¯æŒæ˜¯åœ¨ Go Version 1.18 æ­£å¼æ”¯æŒçš„

æ¥ä¸‹æ¥æ˜¯ Go ä¸ºæ³›å‹å¼•å…¥çš„å…¨æ–°çš„æ¦‚å¿µï¼š

-   ç±»å‹å½¢å‚ (Type parameter)
-   ç±»å‹å®å‚(Type argument)
-   ç±»å‹å½¢å‚åˆ—è¡¨( Type parameter list)
-   ç±»å‹çº¦æŸ(Type constraint)
-   å®ä¾‹åŒ–(Instantiations)
-   æ³›å‹ç±»å‹(Generic type)
-   æ³›å‹æ¥æ”¶å™¨(Generic receiver)
-   æ³›å‹å‡½æ•°(Generic function)
-   è¿˜æœ‰ä¸€äº›... (ç¡®å®å¢åŠ äº†è¯­è¨€çš„éš¾åº¦ï¼Œéš¾æ€ªç¤¾åŒºæ­¤é—®é¢˜åˆ†åŒ–ä¸¥é‡~~~)

## 1. ç±»å‹å½¢å‚ã€ç±»å‹å®å‚ã€ç±»å‹çº¦æŸå’Œæ³›å‹ç±»å‹

```go
type IntSlice []int

var a IntSlice = []int{1, 2, 3} // æ­£ç¡®
var b IntSlice = []float32{1.0, 2.0, 3.0} // âœ— é”™è¯¯ï¼Œå› ä¸ºIntSliceçš„åº•å±‚ç±»å‹æ˜¯[]intï¼Œæµ®ç‚¹ç±»å‹çš„åˆ‡ç‰‡æ— æ³•èµ‹å€¼
```

è¿™é‡Œå®šä¹‰äº†ä¸€ä¸ªæ–°çš„ç±»å‹ `IntSlice` ï¼Œå®ƒçš„åº•å±‚ç±»å‹æ˜¯ `[]int` ï¼Œç†æ‰€å½“ç„¶åªæœ‰ int ç±»å‹çš„åˆ‡ç‰‡èƒ½èµ‹å€¼ç»™ `IntSlice` ç±»å‹çš„å˜é‡

å¦‚æœæƒ³è¦å¼•å…¥æ›´å¤šçš„ç±»å‹æ”¯æŒè¯¥æ€ä¹ˆåŠï¼Ÿ

> ç»™æ¯ç§ç±»å‹éƒ½å®šä¹‰ä¸ªæ–°ç±»å‹ ğŸ˜‚ğŸ˜‚ğŸ˜‚ æ˜¯ä¸æ˜¯å·²ç»æ„Ÿè§‰åˆ°äº†ç—›è‹¦

```go
type StringSlice []string
type Float32Slie []float32
type Float64Slice []float64
```

æœ‰æ²¡æœ‰ä»€ä¹ˆæ–¹æ¡ˆè§£å†³è¿™ä¸ªé—®é¢˜ï¼Ÿ

```go
type Slice[T int|float32|float64 ] []T
```

æ”¹è¿›ä¸€ä¸‹ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å®¹çº³å¤šä¸ªç±»å‹äº†ï¼Œçœ‹èµ·æ¥å¥½åƒæ˜¯æœ‰é‚£ä¹ˆä¸€å›äº‹ï¼Œä¸åƒ Javaã€C#ï¼Œ ä½†æ˜¯è·Ÿä¸€ä¸ªæ‰©å±•è¯­è¨€éå¸¸ç›¸ä¼¼ `TypeScript`

ä¸åŒäºä¸€èˆ¬çš„ç±»å‹å®šä¹‰ï¼Œè¿™é‡Œç±»å‹åç§° `Slice` åå¸¦äº†ä¸­æ‹¬å·ï¼Œå¯¹å„ä¸ªéƒ¨åˆ†åšä¸€ä¸ªè§£è¯´å°±æ˜¯ï¼š

-   `T` å°±æ˜¯ä¸Šé¢ä»‹ç»è¿‡çš„`ç±»å‹å½¢å‚(Type parameter)`ï¼Œåœ¨å®šä¹‰ Slice ç±»å‹çš„æ—¶å€™ T ä»£è¡¨çš„å…·ä½“ç±»å‹å¹¶ä¸ç¡®å®šï¼Œç±»ä¼¼ä¸€ä¸ªå ä½ç¬¦
-   `int|float32|float64` è¿™éƒ¨åˆ†è¢«ç§°ä¸º`ç±»å‹çº¦æŸ(Type constraint)`ï¼Œä¸­é—´çš„ `|` çš„æ„æ€æ˜¯å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œç±»å‹å½¢å‚ T åªå¯ä»¥æ¥æ”¶ int æˆ– float32 æˆ– float64 è¿™ä¸‰ç§ç±»å‹çš„å®å‚
-   ä¸­æ‹¬å·é‡Œçš„ `T int|float32|float64` è¿™ä¸€æ•´ä¸²å› ä¸ºå®šä¹‰äº†æ‰€æœ‰çš„ç±»å‹å½¢å‚(åœ¨è¿™ä¸ªä¾‹å­é‡Œåªæœ‰ä¸€ä¸ªç±»å‹å½¢å‚ Tï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬ç§°å…¶ä¸º`ç±»å‹å½¢å‚åˆ—è¡¨(type parameter list)`
-   è¿™é‡Œæ–°å®šä¹‰çš„ç±»å‹åç§°å« `Slice[T]`

è¿™ç§ç±»å‹å®šä¹‰çš„æ–¹å¼ä¸­å¸¦äº†ç±»å‹å½¢å‚ï¼Œå¾ˆæ˜æ˜¾å’Œæ™®é€šçš„ç±»å‹å®šä¹‰éå¸¸ä¸ä¸€æ ·ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†è¿™ç§

> ç±»å‹å®šä¹‰ä¸­å¸¦ `ç±»å‹å½¢å‚` çš„ç±»å‹ï¼Œç§°ä¹‹ä¸º `æ³›å‹ç±»å‹(Generic type)`

æ³›å‹ç±»å‹**ä¸èƒ½ç›´æ¥æ‹¿æ¥ä½¿ç”¨**ï¼Œå¿…é¡»ä¼ å…¥**ç±»å‹å®å‚(Type argument)** å°†å…¶ç¡®å®šä¸º**å…·ä½“çš„ç±»å‹**ä¹‹åæ‰å¯ä½¿ç”¨ã€‚è€Œä¼ å…¥ç±»å‹å®å‚ç¡®å®šå…·ä½“ç±»å‹çš„æ“ä½œè¢«ç§°ä¸º **å®ä¾‹åŒ–(Instantiations)** ï¼š

```go
// è¿™é‡Œä¼ å…¥äº†ç±»å‹å®å‚intï¼Œæ³›å‹ç±»å‹Slice[T]è¢«å®ä¾‹åŒ–ä¸ºå…·ä½“çš„ç±»å‹ Slice[int]
var a Slice[int] = []int{1, 2, 3}
fmt.Printf("Type Name: %T",a)  //è¾“å‡ºï¼šType Name: Slice[int]

// ä¼ å…¥ç±»å‹å®å‚float32, å°†æ³›å‹ç±»å‹Slice[T]å®ä¾‹åŒ–ä¸ºå…·ä½“çš„ç±»å‹ Slice[string]
var b Slice[float32] = []float32{1.0, 2.0, 3.0}
fmt.Printf("Type Name: %T",b)  //è¾“å‡ºï¼šType Name: Slice[float32]

// âœ— é”™è¯¯ã€‚å› ä¸ºå˜é‡açš„ç±»å‹ä¸ºSlice[int]ï¼Œbçš„ç±»å‹ä¸ºSlice[float32]ï¼Œä¸¤è€…ç±»å‹ä¸åŒ
a = b

// âœ— é”™è¯¯ã€‚stringä¸åœ¨ç±»å‹çº¦æŸ int|float32|float64 ä¸­ï¼Œä¸èƒ½ç”¨æ¥å®ä¾‹åŒ–æ³›å‹ç±»å‹
var c Slice[string] = []string{"Hello", "World"}

// âœ— é”™è¯¯ã€‚Slice[T]æ˜¯æ³›å‹ç±»å‹ï¼Œä¸å¯ç›´æ¥ä½¿ç”¨å¿…é¡»å®ä¾‹åŒ–ä¸ºå…·ä½“çš„ç±»å‹
var x Slice[T] = []int{1, 2, 3}
```

çœ‹ä¸€ä¸ªæ¯”è¾ƒå¤æ‚çš„ä¾‹å­

```go
// MyMapç±»å‹å®šä¹‰äº†ä¸¤ä¸ªç±»å‹å½¢å‚ KEY å’Œ VALUEã€‚åˆ†åˆ«ä¸ºä¸¤ä¸ªå½¢å‚æŒ‡å®šäº†ä¸åŒçš„ç±»å‹çº¦æŸ
// è¿™ä¸ªæ³›å‹ç±»å‹çš„åå­—å«ï¼š MyMap[KEY, VALUE]
type MyMap[KEY int | string, VALUE float32 | float64] map[KEY]VALUE

// ç”¨ç±»å‹å®å‚ string å’Œ flaot64 æ›¿æ¢äº†ç±»å‹å½¢å‚ KEY ã€ VALUEï¼Œæ³›å‹ç±»å‹è¢«å®ä¾‹åŒ–ä¸ºå…·ä½“çš„ç±»å‹ï¼šMyMap[string, float64]
var a MyMap[string, float64] = map[string]float64{
    "jack_score": 9.6,
    "bob_score":  8.4,
}
```

è§£æä¸€ä¸‹ä¸Šé¢å®šä¹‰çš„ç±»å‹:

-   KEY å’Œ VALUE æ˜¯**ç±»å‹å½¢å‚**
-   `int|string` æ˜¯ KEY çš„**ç±»å‹çº¦æŸ**ï¼Œ float32|float64 æ˜¯ VALUE çš„**ç±»å‹çº¦æŸ**
-   `KEY int|string, VALUE float32|float64` æ•´ä¸ªä¸€ä¸²æ–‡æœ¬å› ä¸ºå®šä¹‰äº†æ‰€æœ‰å½¢å‚æ‰€ä»¥è¢«ç§°ä¸ºç±»å‹å½¢å‚åˆ—è¡¨
-   **Map[KEY, VALUE] æ˜¯æ³›å‹ç±»å‹**ï¼Œç±»å‹çš„åå­—å°±å« Map[KEY, VALUE]
-   `var a MyMap[string, float64] = xx` ä¸­çš„ string å’Œ float64 æ˜¯**ç±»å‹å®å‚**ï¼Œç”¨äºåˆ†åˆ«æ›¿æ¢ KEY å’Œ VALUEï¼Œå®ä¾‹åŒ–å‡ºäº†å…·ä½“çš„ç±»å‹ `MyMap[string, float64]`

### 1. å…¶ä»–çš„æ³›å‹ç±»å‹

æ‰€æœ‰ç±»å‹å®šä¹‰éƒ½å¯ä½¿ç”¨ç±»å‹å½¢å‚ï¼Œæ‰€ä»¥ä¸‹é¢è¿™ç§ç»“æ„ä½“ä»¥åŠæ¥å£çš„å®šä¹‰ä¹Ÿå¯ä»¥ä½¿ç”¨ç±»å‹å½¢å‚ï¼š

```go
// ä¸€ä¸ªæ³›å‹ç±»å‹çš„ç»“æ„ä½“ã€‚å¯ç”¨ int æˆ– sring ç±»å‹å®ä¾‹åŒ–
type MyStruct[T int | string] struct {
    Name string
    Data T
}

// ä¸€ä¸ªæ³›å‹æ¥å£(å…³äºæ³›å‹æ¥å£åœ¨ååŠéƒ¨åˆ†ä¼šè¯¦ç»†è®²è§£ï¼‰
type IPrintData[T int | float32 | string] interface {
    Print(data T)
}

// ä¸€ä¸ªæ³›å‹é€šé“ï¼Œå¯ç”¨ç±»å‹å®å‚ int æˆ– string å®ä¾‹åŒ–
type MyChan[T int | string] chan T
```

### 2. ç±»å‹å½¢å‚çš„äº’ç›¸å¥—ç”¨

```go
type WowStruct[T int | float32, S []T] struct {
    Data     S
    MaxValue T
    MinValue T
}
```

è¿™ä¸ªä¾‹å­çœ‹èµ·æ¥æœ‰ç‚¹å¤æ‚ä¸”éš¾ä»¥ç†è§£ï¼Œä½†å®é™…ä¸Šåªè¦è®°ä½ä¸€ç‚¹ï¼šä»»ä½•æ³›å‹ç±»å‹éƒ½å¿…é¡»ä¼ å…¥ç±»å‹å®å‚å®ä¾‹åŒ–æ‰å¯ä»¥ä½¿ç”¨

```go
var ws WowStruct[int, []int]
// æ³›å‹ç±»å‹ WowStuct[T, S] è¢«å®ä¾‹åŒ–åçš„ç±»å‹åç§°å°±å« WowStruct[int, []int]
```

ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¸º T ä¼ å…¥äº†å®å‚ `int`ï¼Œç„¶åå› ä¸º S çš„å®šä¹‰æ˜¯ `[]T` ï¼Œæ‰€ä»¥ S çš„å®å‚è‡ªç„¶æ˜¯ `[]int` ã€‚ç»è¿‡å®ä¾‹åŒ–ä¹‹å `WowStruct[T,S]` çš„å®šä¹‰ç±»ä¼¼å¦‚ä¸‹ï¼š

```go
// ä¸€ä¸ªå­˜å‚¨intç±»å‹åˆ‡ç‰‡ï¼Œä»¥åŠåˆ‡ç‰‡ä¸­æœ€å¤§ã€æœ€å°å€¼çš„ç»“æ„ä½“
type WowStruct[int, []int] struct {
    Data     []int
    MaxValue int
    MinValue int
}
```

é”™è¯¯çš„ç¤ºèŒƒï¼š

```go
// é”™è¯¯ã€‚Sçš„å®šä¹‰æ˜¯[]Tï¼Œè¿™é‡ŒTä¼ å…¥äº†å®å‚int, æ‰€ä»¥Sçš„å®å‚åº”å½“ä¸º []int è€Œä¸èƒ½æ˜¯ []float32
ws := WowStruct[int, []float32]{
        Data:     []float32{1.0, 2.0, 3.0},
        MaxValue: 3,
        MinValue: 1,
    }
```

### 3. å‡ ç§å¸¸è§çš„è¯­æ³•é”™è¯¯

#### 1. å®šä¹‰æ³›å‹ç±»å‹çš„æ—¶å€™ï¼ŒåŸºç¡€ç±»å‹ä¸èƒ½åªæœ‰ç±»å‹å½¢å‚ï¼Œå¦‚ä¸‹ï¼š

```go
// é”™è¯¯ï¼Œç±»å‹å½¢å‚ä¸èƒ½å•ç‹¬ä½¿ç”¨
type CommonType[T int|string|float32] T
```

#### 2. å½“ç±»å‹çº¦æŸçš„ä¸€äº›å†™æ³•ä¼šè¢«ç¼–è¯‘å™¨è¯¯è®¤ä¸ºæ˜¯è¡¨è¾¾å¼æ—¶ä¼šæŠ¥é”™ã€‚å¦‚ä¸‹ï¼š

```go
//âœ— é”™è¯¯ã€‚T *intä¼šè¢«ç¼–è¯‘å™¨è¯¯è®¤ä¸ºæ˜¯è¡¨è¾¾å¼ Tä¹˜ä»¥intï¼Œè€Œä¸æ˜¯intæŒ‡é’ˆ
type NewType[T *int] []T
// ä¸Šé¢ä»£ç å†ç¼–è¯‘å™¨çœ¼ä¸­ï¼šå®ƒè®¤ä¸ºä½ è¦å®šä¹‰ä¸€ä¸ªå­˜æ”¾åˆ‡ç‰‡çš„æ•°ç»„ï¼Œæ•°ç»„é•¿åº¦ç”± T ä¹˜ä»¥ int è®¡ç®—å¾—åˆ°
type NewType [T * int][]T

//âœ— é”™è¯¯ã€‚å’Œä¸Šé¢ä¸€æ ·ï¼Œè¿™é‡Œä¸å…‰*è¢«ä¼šè®¤ä¸ºæ˜¯ä¹˜å·ï¼Œ| è¿˜ä¼šè¢«è®¤ä¸ºæ˜¯æŒ‰ä½æˆ–æ“ä½œ
type NewType2[T *int|*float64] []T

//âœ— é”™è¯¯
type NewType2 [T (int)] []T
```

ä¸ºäº†é¿å…è¿™ç§è¯¯è§£ï¼Œè§£å†³åŠæ³•å°±æ˜¯ç»™ç±»å‹çº¦æŸåŒ…ä¸Š interface{} æˆ–åŠ ä¸Šé€—å·æ¶ˆé™¤æ­§ä¹‰

```go
type NewType[T interface{*int}] []T
type NewType2[T interface{*int|*float64}] []T

// å¦‚æœç±»å‹çº¦æŸä¸­åªæœ‰ä¸€ä¸ªç±»å‹ï¼Œå¯ä»¥æ·»åŠ ä¸ªé€—å·æ¶ˆé™¤æ­§ä¹‰ (ä¸æ¨èï¼Œè§„èŒƒç¼–ç¨‹ç»Ÿä¸€å†™æ³•æ¯”è¾ƒå¥½)
type NewType3[T *int,] []T

//âœ— é”™è¯¯ã€‚å¦‚æœç±»å‹çº¦æŸä¸æ­¢ä¸€ä¸ªç±»å‹ï¼ŒåŠ é€—å·æ˜¯ä¸è¡Œçš„
type NewType4[T *int|*float32,] []T
```

### 4. ç‰¹æ®Šçš„æ³›å‹ç±»å‹

```go
type Wow[T int | string] int

var a Wow[int] = 123     // ç¼–è¯‘æ­£ç¡®
var b Wow[string] = 123  // ç¼–è¯‘æ­£ç¡®
var c Wow[string] = "hello" // ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸º"hello"ä¸èƒ½èµ‹å€¼ç»™åº•å±‚ç±»å‹int
```

è¿™é‡Œè™½ç„¶ä½¿ç”¨äº†ç±»å‹å½¢å‚ï¼Œä½†å› ä¸ºç±»å‹å®šä¹‰æ˜¯ `type Wow[T int|string] int`ï¼Œæ‰€ä»¥æ— è®ºä¼ å…¥ä»€ä¹ˆç±»å‹å®å‚ï¼Œå®ä¾‹åŒ–åçš„æ–°ç±»å‹çš„åº•å±‚ç±»å‹éƒ½æ˜¯ int ã€‚æ‰€ä»¥ int ç±»å‹çš„æ•°å­— 123 å¯ä»¥èµ‹å€¼ç»™å˜é‡ a å’Œ bï¼Œä½† string ç±»å‹çš„å­—ç¬¦ä¸² â€œhelloâ€ ä¸èƒ½èµ‹å€¼ç»™ c

### 5. æ³›å‹ç±»å‹çš„åµŒå¥—

æ³›å‹å’Œæ™®é€šçš„ç±»å‹ä¸€æ ·ï¼Œå¯ä»¥äº’ç›¸åµŒå¥—å®šä¹‰å‡ºæ›´åŠ å¤æ‚çš„æ–°ç±»å‹ï¼Œå¦‚ä¸‹ï¼š

```go
// å…ˆå®šä¹‰ä¸ªæ³›å‹ç±»å‹ Slice[T]
type Slice[T int|string|float32|float64] []T

// âœ— é”™è¯¯ã€‚æ³›å‹ç±»å‹Slice[T]çš„ç±»å‹çº¦æŸä¸­ä¸åŒ…å«uint, uint8
type UintSlice[T uint|uint8] Slice[T]

// âœ“ æ­£ç¡®ã€‚åŸºäºæ³›å‹ç±»å‹Slice[T]å®šä¹‰äº†æ–°çš„æ³›å‹ç±»å‹ FloatSlice[T] ã€‚FloatSlice[T]åªæ¥å—float32å’Œfloat64ä¸¤ç§ç±»å‹
type FloatSlice[T float32|float64] Slice[T]

// âœ“ æ­£ç¡®ã€‚åŸºäºæ³›å‹ç±»å‹Slice[T]å®šä¹‰çš„æ–°æ³›å‹ç±»å‹ IntAndStringSlice[T]
type IntAndStringSlice[T int|string] Slice[T]
// âœ“ æ­£ç¡® åŸºäºIntAndStringSlice[T]å¥—å¨ƒå®šä¹‰å‡ºçš„æ–°æ³›å‹ç±»å‹
type IntSlice[T int] IntAndStringSlice[T]

// åœ¨mapä¸­å¥—ä¸€ä¸ªæ³›å‹ç±»å‹Slice[T]
type WowMap[T int|string] map[string]Slice[T]
// åœ¨mapä¸­å¥—Slice[T]çš„å¦ä¸€ç§å†™æ³•
type WowMap2[T Slice[int] | Slice[string]] map[string]T
```

### 6. ç±»å‹çº¦æŸçš„ä¸¤ç§é€‰æ‹©

```go
type WowStruct[T int|string] struct {
    Name string
    Data []T
}

type WowStruct2[T []int|[]string] struct {
    Name string
    Data T
}
```

è¿™ä¸¤ç§å†™æ³•å’Œå®ç°çš„åŠŸèƒ½å…¶å®æ˜¯å·®ä¸å¤šçš„ï¼Œå®ä¾‹åŒ–ä¹‹åç»“æ„ä½“ç›¸åŒã€‚ä½†æ˜¯åƒä¸‹é¢è¿™ç§æƒ…å†µçš„æ—¶å€™ï¼Œæˆ‘ä»¬ä½¿ç”¨å‰ä¸€ç§å†™æ³•ä¼šæ›´å¥½ï¼š

```go
type WowStruct3[T int | string] struct {
    Data     []T
    MaxValue T
    MinValue T
}
```

### 7 åŒ¿åç»“æ„ä½“ä¸æ”¯æŒæ³›å‹

æˆ‘ä»¬æœ‰æ—¶å€™ä¼šç»å¸¸ç”¨åˆ°åŒ¿åçš„ç»“æ„ä½“ï¼Œå¹¶åœ¨å®šä¹‰å¥½åŒ¿åç»“æ„ä½“ä¹‹åç›´æ¥åˆå§‹åŒ–ï¼š

```go
testCase := struct {
        caseName string
        got      int
        want     int
    }{
        caseName: "test OK",
        got:      100,
        want:     100,
    }

// é”™è¯¯å†™æ³•
testCase := struct[T int|string] {
        caseName string
        got      T
        want     T
    }[int]{
        caseName: "test OK",
        got:      100,
        want:     100,
    }
```

æ‰€ä»¥åœ¨ä½¿ç”¨æ³›å‹çš„æ—¶å€™æˆ‘ä»¬åªèƒ½æ”¾å¼ƒä½¿ç”¨åŒ¿åç»“æ„ä½“ï¼Œå¯¹äºå¾ˆå¤šåœºæ™¯æ¥è¯´è¿™ä¼šé€ æˆéº»çƒ¦ï¼ˆæ¯”å¦‚æœ€å¸¸è§çš„å•å…ƒæµ‹è¯•ï¼‰

## 2. æ³›å‹ receiver

åœ¨æˆ‘ä»¬å®šä¹‰äº†æ³›å‹ç±»å‹åï¼Œä¹Ÿå¯ä»¥ç»™æ³›å‹ç±»å‹æ·»åŠ æ–¹æ³•ï¼š

```go
type MySlice[T int | float32] []T

func (s MySlice[T]) Sum() T {
    var sum T
    for _, value := range s {
        sum += value
    }
    return sum
}
```

è¿™ä¸ªä¾‹å­ä¸ºæ³›å‹ç±»å‹ MySlice[T] æ·»åŠ äº†ä¸€ä¸ªè®¡ç®—æˆå‘˜æ€»å’Œçš„æ–¹æ³• Sum() ã€‚æ³¨æ„è§‚å¯Ÿè¿™ä¸ªæ–¹æ³•çš„å®šä¹‰ï¼š

-   é¦–å…ˆçœ‹ receiver `(s MySlice[T])` ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥æŠŠç±»å‹åç§° `MySlice[T]` å†™å…¥äº† receiver ä¸­
-   ç„¶åæ–¹æ³•çš„è¿”å›å‚æ•°æˆ‘ä»¬ä½¿ç”¨äº†ç±»å‹å½¢å‚ `T` (å®é™…ä¸Šå¦‚æœæœ‰éœ€è¦çš„è¯ï¼Œæ–¹æ³•çš„æ¥æ”¶å‚æ•°ä¹Ÿå¯ä»¥å®ç”¨ç±»å‹å½¢å‚)
-   åœ¨æ–¹æ³•çš„å®šä¹‰ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ç±»å‹å½¢å‚ `T` ï¼ˆåœ¨è¿™ä¸ªä¾‹å­é‡Œï¼Œæˆ‘ä»¬é€šè¿‡ `var sum T` å®šä¹‰äº†ä¸€ä¸ªæ–°çš„å˜é‡ `sum` )

å¯¹äºè¿™ä¸ªæ³›å‹ç±»å‹ MySlice[T] æˆ‘ä»¬è¯¥å¦‚ä½•ä½¿ç”¨ï¼Ÿ

```go
var s MySlice[int] = []int{1, 2, 3, 4}
fmt.Println(s.Sum()) // è¾“å‡ºï¼š10

var s2 MySlice[float32] = []float32{1.0, 2.0, 3.0, 4.0}
fmt.Println(s2.Sum()) // è¾“å‡ºï¼š10.0
```

è¯¥å¦‚ä½•ç†è§£ä¸Šé¢çš„å®ä¾‹åŒ–ï¼Ÿé¦–å…ˆæˆ‘ä»¬ç”¨ç±»å‹å®å‚ `int` å®ä¾‹åŒ–äº†æ³›å‹ç±»å‹ `MySlice[T]`ï¼Œæ‰€ä»¥æ³›å‹ç±»å‹å®šä¹‰ä¸­çš„æ‰€æœ‰ `T` éƒ½è¢«æ›¿æ¢ä¸º `int`ï¼Œæœ€ç»ˆæˆ‘ä»¬å¯ä»¥æŠŠä»£ç çœ‹ä½œä¸‹é¢è¿™æ ·ï¼š

```go
type MySlice[int] []int // å®ä¾‹åŒ–åçš„ç±»å‹åå« MyIntSlice[int]

// æ–¹æ³•ä¸­æ‰€æœ‰ç±»å‹å½¢å‚ T éƒ½è¢«æ›¿æ¢ä¸ºç±»å‹å®å‚ int
func (s MySlice[int]) Sum() int {
    var sum int
    for _, value := range s {
        sum += value
    }
    return sum
}
```

åœ¨è¿™é‡Œå½“ç„¶ä¹Ÿå¯ä»¥ä½¿ç”¨ `float32` å®ä¾‹åŒ–

é€šè¿‡æ³›å‹ receiverï¼Œæ³›å‹çš„å®ç”¨æ€§ä¸€ä¸‹å­å¾—åˆ°äº†å·¨å¤§çš„æ‰©å±•ã€‚åœ¨æ²¡æœ‰æ³›å‹ä¹‹å‰å¦‚æœæƒ³å®ç°é€šç”¨çš„æ•°æ®ç»“æ„ï¼Œè¯¸å¦‚ï¼šå †ã€æ ˆã€é˜Ÿåˆ—ã€é“¾è¡¨ä¹‹ç±»çš„è¯ï¼Œæˆ‘ä»¬çš„é€‰æ‹©åªæœ‰ä¸¤ä¸ªï¼š

-   ä¸ºæ¯ç§ç±»å‹å†™ä¸€ä¸ªå®ç°
-   ä½¿ç”¨ æ¥å£+åå°„

è€Œæœ‰äº†æ³›å‹ä¹‹åï¼Œæˆ‘ä»¬å°±èƒ½éå¸¸ç®€å•åœ°åˆ›å»ºé€šç”¨æ•°æ®ç»“æ„äº†

### 1. åŸºäºæ³›å‹çš„é˜Ÿåˆ—

é˜Ÿåˆ—æ˜¯ä¸€ç§**å…ˆå…¥å…ˆå‡º(FIFO)**çš„æ•°æ®ç»“æ„ï¼Œæ•°æ®åªèƒ½ä»**é˜Ÿå°¾æ”¾å…¥ã€ä»é˜Ÿé¦–å–å‡º**ï¼Œ**å…ˆæ”¾å…¥çš„æ•°æ®ä¼˜å…ˆè¢«å–å‡ºæ¥**

```go
// è¿™é‡Œç±»å‹çº¦æŸä½¿ç”¨äº†ç©ºæ¥å£ï¼Œä»£è¡¨çš„æ„æ€æ˜¯æ‰€æœ‰ç±»å‹éƒ½å¯ä»¥ç”¨æ¥å®ä¾‹åŒ–æ³›å‹ç±»å‹ Queue[T]
type Queue[T interface{}] struct {
    elements []T
}

// å°†æ•°æ®æ”¾å…¥é˜Ÿåˆ—å°¾éƒ¨
func (q *Queue[T]) Put(value T) {
    q.elements = append(q.elements, value)
}

// ä»é˜Ÿåˆ—å¤´éƒ¨å–å‡ºå¹¶ä»å¤´éƒ¨åˆ é™¤å¯¹åº”æ•°æ®
func (q *Queue[T]) Pop() (T, bool) {
    var value T
    if len(q.elements) == 0 {
        return value, true
    }

    value = q.elements[0]
    q.elements = q.elements[1:]
    return value, len(q.elements) == 0
}

// é˜Ÿåˆ—å¤§å°
func (q Queue[T]) Size() int {
    return len(q.elements)
}
```

> ğŸ’¡ ä¸ºäº†æ–¹ä¾¿è¯´æ˜ï¼Œä¸Šé¢æ˜¯é˜Ÿåˆ—éå¸¸ç®€å•çš„ä¸€ç§å®ç°æ–¹æ³•ï¼Œæ²¡æœ‰è€ƒè™‘çº¿ç¨‹å®‰å…¨ç­‰å¾ˆå¤šé—®é¢˜

`Queue[T]` å› ä¸ºæ˜¯æ³›å‹ç±»å‹ï¼Œæ‰€ä»¥è¦ä½¿ç”¨çš„è¯å¿…é¡»å®ä¾‹åŒ–ï¼Œå®ä¾‹åŒ–ä¸ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
var q1 Queue[int]  // å¯å­˜æ”¾intç±»å‹æ•°æ®çš„é˜Ÿåˆ—
q1.Put(1)
q1.Put(2)
q1.Put(3)
q1.Pop() // 1
q1.Pop() // 2
q1.Pop() // 3

var q2 Queue[string]  // å¯å­˜æ”¾stringç±»å‹æ•°æ®çš„é˜Ÿåˆ—
q2.Put("A")
q2.Put("B")
q2.Put("C")
q2.Pop() // "A"
q2.Pop() // "B"
q2.Pop() // "C"

var q3 Queue[struct{Name string}]
var q4 Queue[[]int] // å¯å­˜æ”¾[]intåˆ‡ç‰‡çš„é˜Ÿåˆ—
var q5 Queue[chan int] // å¯å­˜æ”¾inté€šé“çš„é˜Ÿåˆ—
var q6 Queue[io.Reader] // å¯å­˜æ”¾æ¥å£çš„é˜Ÿåˆ—
```

### 2. åŠ¨æ€åˆ¤æ–­å˜é‡çš„ç±»å‹

ä½¿ç”¨æ¥å£çš„æ—¶å€™ç»å¸¸ä¼šç”¨åˆ°ç±»å‹æ–­è¨€æˆ– `type swith` æ¥ç¡®å®šæ¥å£å…·ä½“çš„ç±»å‹ï¼Œç„¶åå¯¹ä¸åŒç±»å‹åšå‡ºä¸åŒçš„å¤„ç†ï¼Œå¦‚ï¼š

```go
var i interface{} = 123
i.(int) // ç±»å‹æ–­è¨€

// type switch
switch i.(type) {
    case int:
        // do something
    case string:
        // do something
    default:
        // do something
    }
}
```

é‚£ä¹ˆå¯ä»¥æ ¹æ®æ­¤æ–¹å¼æ¥è·å–æ³›å‹ç±»å‹ï¼Œç„¶åè¿›ä¸€æ­¥å¤„ç†å—ï¼Ÿ âŒ

```go
func (q *Queue[T]) Put(value T) {
    value.(int) // é”™è¯¯ã€‚æ³›å‹ç±»å‹å®šä¹‰çš„å˜é‡ä¸èƒ½ä½¿ç”¨ç±»å‹æ–­è¨€

    // é”™è¯¯ã€‚ä¸å…è®¸ä½¿ç”¨type switch æ¥åˆ¤æ–­ value çš„å…·ä½“ç±»å‹
    switch value.(type) {
    case int:
        // do something
    case string:
        // do something
    default:
        // do something
    }

    // ...
}
```

é‚£ä¹ˆå¦‚ä½•è·å–çœŸå®çš„ç±»å‹ï¼Ÿ**åå°„**

```go
func (receiver Queue[T]) Put(value T) {
    // Printf() å¯è¾“å‡ºå˜é‡valueçš„ç±»å‹(åº•å±‚å°±æ˜¯é€šè¿‡åå°„å®ç°çš„)
    fmt.Printf("%T", value)

    // é€šè¿‡åå°„å¯ä»¥åŠ¨æ€è·å¾—å˜é‡valueçš„ç±»å‹ä»è€Œåˆ†æƒ…å†µå¤„ç†
    v := reflect.ValueOf(value)

    switch v.Kind() {
    case reflect.Int:
        // do something
    case reflect.String:
        // do something
    }

    // ...
}
```

> è¿™æ ·é—´æ¥çš„è¿åäº†è®¾è®¡æ€æƒ³ï¼Œäº†é¿å…ä½¿ç”¨åå°„è€Œé€‰æ‹©äº†æ³›å‹ï¼Œç„¶ååˆåœ¨æ³›å‹é‡Œä½¿ç”¨åå°„ ğŸ˜‚ï¼Œæ‰€ä»¥åœ¨ä½¿ç”¨æ³›å‹çš„æ—¶å€™è¿˜æ˜¯è¦å¤šåˆ¤æ–­æ˜¯å¦çœŸçš„éœ€è¦æ³›å‹ï¼Œæ¯•ç«Ÿ Go çš„æ³›å‹ä¸åƒ Java ç±»ä¼¼çš„åŸºå› è‡ªå¸¦çš„

## 3. æ³›å‹å‡½æ•°

ç®€å•ä¾‹å­(å¦‚ä½•è®©æˆ‘ä¸æ€€ç–‘ä½ æ˜¯æŠ„è¢­ TypeScript çš„ ğŸ¤£)

```go
func Add[T int | float32 | float64](a T, b T) T {
    return a + b
}
```

> è¿™ç§å¸¦ç±»å‹å½¢å‚çš„å‡½æ•°è¢«ç§°ä¸º**æ³›å‹å‡½æ•°**

å’Œæ³›å‹ç±»å‹ä¸€æ ·ï¼Œæ³›å‹å‡½æ•°ä¹Ÿæ˜¯ä¸èƒ½ç›´æ¥è°ƒç”¨çš„ï¼Œè¦ä½¿ç”¨æ³›å‹å‡½æ•°çš„è¯å¿…é¡»ä¼ å…¥ç±»å‹å®å‚ä¹‹åæ‰èƒ½è°ƒç”¨

```go
Add[int](1,2) // ä¼ å…¥ç±»å‹å®å‚intï¼Œè®¡ç®—ç»“æœä¸º 3
Add[float32](1.0, 2.0) // ä¼ å…¥ç±»å‹å®å‚float32, è®¡ç®—ç»“æœä¸º 3.0

Add[string]("hello", "world") // é”™è¯¯ã€‚å› ä¸ºæ³›å‹å‡½æ•°Addçš„ç±»å‹çº¦æŸä¸­å¹¶ä¸åŒ…å«string
```

å½“ç„¶ Go ä¹Ÿæ˜¯æ”¯æŒè‡ªåŠ¨æ¨å¯¼çš„ï¼ˆä¸ç„¶å†™èµ·ä»£ç æ¥çœŸçš„è¦ç–¯ï¼‰

```go
Add(1, 2)  // 1ï¼Œ2æ˜¯intç±»å‹ï¼Œç¼–è¯‘è¯·è‡ªåŠ¨æ¨å¯¼å‡ºç±»å‹å®å‚Tæ˜¯int
Add(1.0, 2.0) // 1.0, 2.0 æ˜¯æµ®ç‚¹ï¼Œç¼–è¯‘è¯·è‡ªåŠ¨æ¨å¯¼å‡ºç±»å‹å®å‚Tæ˜¯float32
```

> è‡ªåŠ¨æ¨å¯¼çš„å†™æ³•å°±å¥½åƒå…å»äº†ä¼ å…¥å®å‚çš„æ­¥éª¤ä¸€æ ·ï¼Œä½†è¯·è®°ä½è¿™ä»…ä»…åªæ˜¯ç¼–è¯‘å™¨å¸®æˆ‘ä»¬æ¨å¯¼å‡ºäº†ç±»å‹å®å‚ï¼Œå®é™…ä¸Šä¼ å…¥å®å‚æ­¥éª¤è¿˜æ˜¯å‘ç”Ÿäº†çš„

### 1. åŒ¿åå‡½æ•°ä¸æ”¯æŒæ³›å‹

åŒ¿åå‡½æ•°ä¸èƒ½è‡ªå·±å®šä¹‰ç±»å‹å®å‚

```go
// é”™è¯¯
fnGeneric := func[T int | float32](a, b T) T {
        return a + b
}

fmt.Println(fnGeneric(1, 2))
```

ä½†æ˜¯åŒ¿åå‡½æ•°å¯ä»¥ä½¿ç”¨åˆ«å¤„å®šä¹‰å¥½çš„ç±»å‹å®å‚ï¼Œå¦‚ï¼š

```go
func MyFunc[T int | float32 | float64](a, b T) {

    // åŒ¿åå‡½æ•°å¯ä½¿ç”¨å·²ç»å®šä¹‰å¥½çš„ç±»å‹å½¢å‚
    fn2 := func(i T, j T) T {
        return i*2 - j*2
    }

    fn2(a, b)
}
```

### 2. Go çš„æ–¹æ³•å¹¶æ”¯æŒæ³›å‹

```go
type A struct {
}

// ä¸æ”¯æŒæ³›å‹æ–¹æ³•
func (receiver A) Add[T int | float32 | float64](a T, b T) T {
    return a + b
}
```

ä½†æ˜¯å› ä¸º receiver æ”¯æŒæ³›å‹ï¼Œ æ‰€ä»¥å¦‚æœæƒ³åœ¨æ–¹æ³•ä¸­ä½¿ç”¨æ³›å‹çš„è¯ï¼Œç›®å‰å”¯ä¸€çš„åŠæ³•å°±æ˜¯æ›²çº¿æ•‘å›½ï¼Œè¿‚å›åœ°é€šè¿‡ receiver ä½¿ç”¨ç±»å‹å½¢å‚ï¼š

```go
type A[T int | float32 | float64] struct {
}

// æ–¹æ³•å¯ä»¥ä½¿ç”¨ç±»å‹å®šä¹‰ä¸­çš„å½¢å‚ T
func (receiver A[T]) Add(a T, b T) T {
    return a + b
}

// ç”¨æ³•ï¼š
var a A[int]
a.Add(1, 2)

var aa A[float32]
aa.Add(1.0, 2.0)
```

## 4. æ¥å£çš„æ”¹å˜

æœ‰æ—¶å€™ä½¿ç”¨æ³›å‹ç¼–ç¨‹æ—¶ï¼Œæˆ‘ä»¬ä¼šä¹¦å†™é•¿é•¿çš„ç±»å‹çº¦æŸï¼Œå¦‚ä¸‹ï¼š

```go
// ä¸€ä¸ªå¯ä»¥å®¹çº³æ‰€æœ‰int,uintä»¥åŠæµ®ç‚¹ç±»å‹çš„æ³›å‹åˆ‡ç‰‡
type Slice[T int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64] []T
```

è¿™ç§å†™æ³•æ˜¯æˆ‘ä»¬æ— æ³•å¿å—ä¹Ÿéš¾ä»¥ç»´æŠ¤çš„ï¼Œè€Œ Go æ”¯æŒå°†ç±»å‹çº¦æŸå•ç‹¬æ‹¿å‡ºæ¥å®šä¹‰åˆ°æ¥å£ä¸­ï¼Œä»è€Œè®©ä»£ç æ›´å®¹æ˜“ç»´æŠ¤ï¼š

```go
type IntUintFloat interface {
    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64
}

type Slice[T IntUintFloat] []T
```

è¿™æ®µä»£ç æŠŠç±»å‹çº¦æŸç»™å•ç‹¬æ‹¿å‡ºæ¥ï¼Œå†™å…¥äº†æ¥å£ç±»å‹ `IntUintFloat` å½“ä¸­ã€‚éœ€è¦æŒ‡å®šç±»å‹çº¦æŸçš„æ—¶å€™ç›´æ¥ä½¿ç”¨æ¥å£ `IntUintFloat` å³å¯

ä¸è¿‡è¿™æ ·çš„ä»£ç ä¾æ—§ä¸å¥½ç»´æŠ¤ï¼Œè€Œæ¥å£å’Œæ¥å£ã€æ¥å£å’Œæ™®é€šç±»å‹ä¹‹é—´ä¹Ÿæ˜¯å¯ä»¥é€šè¿‡ | è¿›è¡Œç»„åˆï¼š

```go
type Int interface {
    int | int8 | int16 | int32 | int64
}

type Uint interface {
    uint | uint8 | uint16 | uint32
}

type Float interface {
    float32 | float64
}

type Slice[T Int | Uint | Float] []T  // ä½¿ç”¨ '|' å°†å¤šä¸ªæ¥å£ç±»å‹ç»„åˆ
```

ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬åˆ†åˆ«å®šä¹‰äº† `Int`, `Uint`, `Float` ä¸‰ä¸ªæ¥å£ç±»å‹ï¼Œå¹¶æœ€ç»ˆåœ¨ `Slice[T]` çš„ç±»å‹çº¦æŸä¸­é€šè¿‡ä½¿ç”¨ `|` å°†å®ƒä»¬ç»„åˆåˆ°ä¸€èµ·

åŒæ—¶ï¼Œåœ¨æ¥å£é‡Œä¹Ÿèƒ½ç›´æ¥ç»„åˆå…¶ä»–æ¥å£ï¼Œæ‰€ä»¥è¿˜å¯ä»¥åƒä¸‹é¢è¿™æ ·ï¼š

```go
type SliceElement interface {
    Int | Uint | Float | string // ç»„åˆäº†ä¸‰ä¸ªæ¥å£ç±»å‹å¹¶é¢å¤–å¢åŠ äº†ä¸€ä¸ª string ç±»å‹
}

type Slice[T SliceElement] []T
```

### 1. ~æŒ‡å®šåº•å±‚ç±»å‹

ä¸Šé¢å®šä¹‰çš„ Slie[T] è™½ç„¶å¯ä»¥è¾¾åˆ°ç›®çš„ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªç¼ºç‚¹ï¼š

```go
var s1 Slice[int] // æ­£ç¡®

type MyInt int
var s2 Slice[MyInt] // âœ— é”™è¯¯ã€‚MyIntç±»å‹åº•å±‚ç±»å‹æ˜¯int,ä½†å¹¶ä¸æ˜¯intç±»å‹ï¼Œä¸ç¬¦åˆ Slice[T] çš„ç±»å‹çº¦æŸ
```

è¿™é‡Œå‘ç”Ÿé”™è¯¯çš„åŸå› æ˜¯ï¼Œæ³›å‹ç±»å‹ `Slice[T]` å…è®¸çš„æ˜¯ `int` ä½œä¸ºç±»å‹å®å‚ï¼Œè€Œä¸æ˜¯ `MyInt` ï¼ˆè™½ç„¶ MyInt ç±»å‹åº•å±‚ç±»å‹æ˜¯ int ï¼Œä½†å®ƒä¾æ—§ä¸æ˜¯ int ç±»å‹ï¼‰

ä¸ºäº†ä»æ ¹æœ¬ä¸Šè§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒGo æ–°å¢äº†ä¸€ä¸ªç¬¦å· ~ ï¼Œåœ¨ç±»å‹çº¦æŸä¸­ä½¿ç”¨ç±»ä¼¼ ~int è¿™ç§å†™æ³•çš„è¯ï¼Œå°±ä»£è¡¨ç€ä¸å…‰æ˜¯ int ï¼Œæ‰€æœ‰ä»¥ int ä¸ºåº•å±‚ç±»å‹çš„ç±»å‹ä¹Ÿéƒ½å¯ç”¨äºå®ä¾‹åŒ–

ä½¿ç”¨ ~ å¯¹ä»£ç è¿›è¡Œæ”¹å†™ä¹‹åå¦‚ä¸‹ï¼š

```go
type Int interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Uint interface {
    ~uint | ~uint8 | ~uint16 | ~uint32
}
type Float interface {
    ~float32 | ~float64
}

type Slice[T Int | Uint | Float] []T

var s Slice[int] // æ­£ç¡®

type MyInt int
var s2 Slice[MyInt]  // MyIntåº•å±‚ç±»å‹æ˜¯intï¼Œæ‰€ä»¥å¯ä»¥ç”¨äºå®ä¾‹åŒ–

type MyMyInt MyInt
var s3 Slice[MyMyInt]  // æ­£ç¡®ã€‚MyMyInt è™½ç„¶åŸºäº MyInt ï¼Œä½†åº•å±‚ç±»å‹ä¹Ÿæ˜¯intï¼Œæ‰€ä»¥ä¹Ÿèƒ½ç”¨äºå®ä¾‹åŒ–

type MyFloat32 float32  // æ­£ç¡®
var s4 Slice[MyFloat32]
```

:::tip é™åˆ¶ï¼šä½¿ç”¨ ~ æ—¶æœ‰ä¸€å®šçš„é™åˆ¶ï¼š

-   ~åé¢çš„ç±»å‹ä¸èƒ½ä¸ºæ¥å£
-   ~åé¢çš„ç±»å‹å¿…é¡»ä¸ºåŸºæœ¬ç±»å‹

```go
type MyInt int

type _ interface {
    ~[]byte  // æ­£ç¡®
    ~MyInt   // é”™è¯¯ï¼Œ~åçš„ç±»å‹å¿…é¡»ä¸ºåŸºæœ¬ç±»å‹
    ~error   // é”™è¯¯ï¼Œ~åçš„ç±»å‹ä¸èƒ½ä¸ºæ¥å£
}
```

:::

### 2. ä»æ–¹æ³•é›†(Method set)åˆ°ç±»å‹é›†(Type set)

åœ¨ Go1.18 ä¹‹å‰ï¼ŒGo å®˜æ–¹å¯¹ `æ¥å£(interface)` çš„å®šä¹‰æ˜¯ï¼šæ¥å£æ˜¯ä¸€ä¸ªæ–¹æ³•é›†(method set)

> An interface type specifies a method set called its interface

å¦‚ä¸‹é¢è¿™ä¸ªä»£ç ä¸€æ ·ï¼Œ `ReadWriter` æ¥å£å®šä¹‰äº†ä¸€ä¸ªæ¥å£(æ–¹æ³•é›†)ï¼Œè¿™ä¸ªé›†åˆä¸­åŒ…å«äº† `Read()` å’Œ `Write()` è¿™ä¸¤ä¸ªæ–¹æ³•ã€‚æ‰€æœ‰åŒæ—¶å®šä¹‰äº†è¿™ä¸¤ç§æ–¹æ³•çš„ç±»å‹è¢«è§†ä¸ºå®ç°äº†è¿™ä¸€æ¥å£

```go
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}
```

åœ¨ Go1.18 ä¹‹åï¼ŒGo å®˜æ–¹å¯¹ `æ¥å£(interface)` çš„å®šä¹‰æ˜¯ï¼šæ¥å£æ˜¯ä¸€ä¸ªç±»å‹é›†(Type set)

æˆ‘ä»¬å¦‚æœæ¢ä¸€ä¸ªè§’åº¦æ¥é‡æ–°æ€è€ƒä¸Šé¢è¿™ä¸ªæ¥å£çš„è¯ï¼Œä¼šå‘ç°æ¥å£çš„å®šä¹‰å®é™…ä¸Šè¿˜èƒ½è¿™æ ·ç†è§£ï¼š

> æˆ‘ä»¬å¯ä»¥æŠŠ `ReaderWriter` æ¥å£çœ‹æˆä»£è¡¨äº†ä¸€ä¸ª **ç±»å‹çš„é›†åˆ**ï¼Œæ‰€æœ‰å®ç°äº† `Read() Writer()` è¿™ä¸¤ä¸ªæ–¹æ³•çš„ç±»å‹éƒ½åœ¨æ¥å£ä»£è¡¨çš„ç±»å‹é›†åˆå½“ä¸­

é€šè¿‡æ¢ä¸ªè§’åº¦çœ‹å¾…æ¥å£ï¼Œåœ¨æˆ‘ä»¬çœ¼ä¸­æ¥å£çš„å®šä¹‰å°±ä» **æ–¹æ³•é›†(method set)** å˜ä¸ºäº† **ç±»å‹é›†(type set)**ã€‚è€Œ Go1.18 å¼€å§‹å°±æ˜¯ä¾æ®è¿™ä¸€ç‚¹å°†æ¥å£çš„å®šä¹‰æ­£å¼æ›´æ”¹ä¸ºäº† **ç±»å‹é›†(Type set)**

> An interface type defines a type set (ä¸€ä¸ªæ¥å£ç±»å‹å®šä¹‰äº†ä¸€ä¸ªç±»å‹é›†)

```go
type Float interface {
    ~float32 | ~float64
}

type Slice[T Float] []T
```

ç”¨ **ç±»å‹é›†** çš„æ¦‚å¿µç†è§£ä¸Šé¢çš„ä»£ç çš„è¯å°±æ˜¯

> æ¥å£ç±»å‹ `Float` ä»£è¡¨äº†ä¸€ä¸ª **ç±»å‹é›†åˆ**ï¼Œ æ‰€æœ‰ä»¥ `float32` æˆ– `float64` ä¸ºåº•å±‚ç±»å‹çš„ç±»å‹ï¼Œéƒ½åœ¨è¿™ä¸€ç±»å‹é›†ä¹‹ä¸­

è€Œ `type Slice[T Float] []T` ä¸­ï¼Œ **ç±»å‹çº¦æŸ** çš„çœŸæ­£æ„æ€æ˜¯ï¼š

> **ç±»å‹çº¦æŸ** æŒ‡å®šäº†ç±»å‹å½¢å‚å¯æ¥å—çš„ç±»å‹é›†åˆï¼Œåªæœ‰å±äºè¿™ä¸ªé›†åˆä¸­çš„ç±»å‹æ‰èƒ½æ›¿æ¢å½¢å‚ç”¨äºå®ä¾‹åŒ–

```go
var s Slice[int]      // int å±äºç±»å‹é›† Float ï¼Œæ‰€ä»¥intå¯ä»¥ä½œä¸ºç±»å‹å®å‚
var s Slice[chan int] // chan int ç±»å‹ä¸åœ¨ç±»å‹é›† Float ä¸­ï¼Œæ‰€ä»¥é”™è¯¯
```

#### 1. æ¥å£å®ç°(implement)å®šä¹‰çš„å˜åŒ–

æ—¢ç„¶æ¥å£å®šä¹‰å‘ç”Ÿäº†å˜åŒ–ï¼Œé‚£ä¹ˆä» Go1.18 å¼€å§‹ æ¥å£å®ç°(implement) çš„å®šä¹‰è‡ªç„¶ä¹Ÿå‘ç”Ÿäº†å˜åŒ–

å½“æ»¡è¶³ä»¥ä¸‹æ¡ä»¶æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è¯´ **ç±»å‹ T å®ç°äº†æ¥å£ I ( type T implements interface I)**ï¼š

-   T ä¸æ˜¯æ¥å£æ—¶ï¼šç±»å‹ T æ˜¯æ¥å£ I ä»£è¡¨çš„ç±»å‹é›†ä¸­çš„ä¸€ä¸ªæˆå‘˜ (T is an element of the type set of I)
-   T æ˜¯æ¥å£æ—¶ï¼š T æ¥å£ä»£è¡¨çš„ç±»å‹é›†æ˜¯ I ä»£è¡¨çš„ç±»å‹é›†çš„å­é›†(Type set of T is a subset of the type set of I)

#### 2. ç±»å‹çš„å¹¶é›†

å¹¶é›†æˆ‘ä»¬å·²ç»å¾ˆç†Ÿæ‚‰äº†ï¼Œä¹‹å‰ä¸€ç›´ä½¿ç”¨çš„ | ç¬¦å·å°±æ˜¯æ±‚ç±»å‹çš„å¹¶é›†( union )

```go
type Uint interface {  // ç±»å‹é›† Uint æ˜¯ ~uint å’Œ ~uint8 ç­‰ç±»å‹çš„å¹¶é›†
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}
```

#### 3. ç±»å‹çš„äº¤é›†

æ¥å£å¯ä»¥ä¸æ­¢ä¹¦å†™ä¸€è¡Œï¼Œå¦‚æœä¸€ä¸ªæ¥å£æœ‰å¤šè¡Œç±»å‹å®šä¹‰ï¼Œé‚£ä¹ˆå–å®ƒä»¬ä¹‹é—´çš„ **äº¤é›†**

```go
type AllInt interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint32
}

type Uint interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type A interface { // æ¥å£Aä»£è¡¨çš„ç±»å‹é›†æ˜¯ AllInt å’Œ Uint çš„äº¤é›†
    AllInt
    Uint
}

type B interface { // æ¥å£Bä»£è¡¨çš„ç±»å‹é›†æ˜¯ AllInt å’Œ ~int çš„äº¤é›†
    AllInt
    ~int
}
```

ä¸Šé¢è¿™ä¸ªä¾‹å­ä¸­:

-   æ¥å£ A ä»£è¡¨çš„æ˜¯ AllInt ä¸ Uint çš„ **äº¤é›†**ï¼Œå³ `~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64`
    æ¥å£ B ä»£è¡¨çš„åˆ™æ˜¯ AllInt å’Œ ~int çš„ **äº¤é›†**ï¼Œå³ `~int`

é™¤äº†ä¸Šé¢çš„äº¤é›†ï¼Œä¸‹é¢ä¹Ÿæ˜¯ä¸€ç§äº¤é›†ï¼š

```go
type C interface {
    ~int
    int
}
```

> ~int å’Œ int çš„äº¤é›†åªæœ‰ int ä¸€ç§ç±»å‹ï¼Œæ‰€ä»¥æ¥å£ C ä»£è¡¨çš„ç±»å‹é›†ä¸­åªæœ‰ int ä¸€ç§ç±»å‹

#### 4. ç©ºé›†

å½“å¤šä¸ªç±»å‹çš„äº¤é›†å¦‚ä¸‹é¢ Bad è¿™æ ·ä¸ºç©ºçš„æ—¶å€™ï¼Œ Bad è¿™ä¸ªæ¥å£ä»£è¡¨çš„ç±»å‹é›†ä¸ºä¸€ä¸ª**ç©ºé›†**ï¼š

```go
type Bad interface {
    int
    float32
} // ç±»å‹ int å’Œ float32 æ²¡æœ‰ç›¸äº¤çš„ç±»å‹ï¼Œæ‰€ä»¥æ¥å£ Bad ä»£è¡¨çš„ç±»å‹é›†ä¸ºç©º
```

**æ²¡æœ‰ä»»ä½•ä¸€ç§ç±»å‹å±äºç©ºé›†**ã€‚å¯ä»¥ç¼–è¯‘é€šè¿‡ä½†æ˜¯æ²¡æœ‰æ„ä¹‰ï¼ˆç­‰å¾…é»‘é­”æ³• ğŸ¤”ï¼‰

#### 5. ç©ºæ¥å£å’Œ any

ä¸Šé¢è¯´äº†ç©ºé›†ï¼Œæ¥ä¸‹æ¥è¯´ä¸€ä¸ªç‰¹æ®Šçš„ç±»å‹é›†â€”â€”ç©ºæ¥å£ `interface{}` ã€‚å› ä¸ºï¼ŒGo1.18 å¼€å§‹æ¥å£çš„å®šä¹‰å‘ç”Ÿäº†æ”¹å˜ï¼Œæ‰€ä»¥ `interface{}` çš„å®šä¹‰ä¹Ÿå‘ç”Ÿäº†ä¸€äº›å˜æ›´ï¼š

> **ç©ºæ¥å£ä»£è¡¨äº†æ‰€æœ‰ç±»å‹çš„é›†åˆ**

æ‰€ä»¥ï¼Œå¯¹äº Go1.18 ä¹‹åçš„ç©ºæ¥å£åº”è¯¥è¿™æ ·ç†è§£ï¼š

-   è™½ç„¶ç©ºæ¥å£å†…æ²¡æœ‰å†™å…¥ä»»ä½•çš„ç±»å‹ï¼Œä½†å®ƒä»£è¡¨çš„æ˜¯æ‰€æœ‰ç±»å‹çš„é›†åˆï¼Œè€Œéä¸€ä¸ª **ç©ºé›†**
-   ç±»å‹çº¦æŸä¸­æŒ‡å®š **ç©ºæ¥å£** çš„æ„æ€æ˜¯æŒ‡å®šäº†ä¸€ä¸ªåŒ…å«æ‰€æœ‰ç±»å‹çš„ç±»å‹é›†ï¼Œå¹¶ä¸æ˜¯ç±»å‹çº¦æŸé™å®šäº†åªèƒ½ä½¿ç”¨ **ç©ºæ¥å£** æ¥åšç±»å‹å½¢å‚

```go
// ç©ºæ¥å£ä»£è¡¨æ‰€æœ‰ç±»å‹çš„é›†åˆã€‚å†™å…¥ç±»å‹çº¦æŸæ„å‘³ç€æ‰€æœ‰ç±»å‹éƒ½å¯æ‹¿æ¥åšç±»å‹å®å‚
type Slice[T interface{}] []T

var s1 Slice[int]    // æ­£ç¡®
var s2 Slice[map[string]string]  // æ­£ç¡®
var s3 Slice[chan int]  // æ­£ç¡®
var s4 Slice[interface{}]  // æ­£ç¡®
```

å› ä¸ºç©ºæ¥å£æ˜¯ä¸€ä¸ªåŒ…å«äº†æ‰€æœ‰ç±»å‹çš„ç±»å‹é›†ï¼Œæ‰€ä»¥æˆ‘ä»¬ç»å¸¸ä¼šç”¨åˆ°å®ƒã€‚äºæ˜¯ï¼ŒGo1.18 å¼€å§‹æä¾›äº†ä¸€ä¸ªå’Œç©ºæ¥å£` interface{}` ç­‰ä»·çš„æ–°å…³é”®è¯ `any` ï¼Œç”¨æ¥ä½¿ä»£ç æ›´ç®€å•ï¼š

```go
type Slice[T any] []T // ä»£ç ç­‰ä»·äº type Slice[T interface{}] []T
```

å®é™…ä¸Š any çš„å®šä¹‰å°±ä½äº Go è¯­è¨€çš„ builtin.go æ–‡ä»¶ä¸­ï¼ˆå‚è€ƒå¦‚ä¸‹ï¼‰ï¼Œ any å®é™…ä¸Šå°±æ˜¯ interaface{} çš„åˆ«å(alias)ï¼Œä¸¤è€…å®Œå…¨ç­‰ä»·

```go
// any is an alias for interface{} and is equivalent to interface{} in all ways.
type any = interface{}
```

ä» Go 1.18 å¼€å§‹ï¼Œæ‰€æœ‰å¯ä»¥ç”¨åˆ°ç©ºæ¥å£çš„åœ°æ–¹å…¶å®éƒ½å¯ä»¥ç›´æ¥æ›¿æ¢ä¸º anyï¼Œå¦‚ï¼š

```go
var s []any // ç­‰ä»·äº var s []interface{}
var m map[string]any // ç­‰ä»·äº var m map[string]interface{}

func MyPrint(value any){
    fmt.Println(value)
}
```

å¦‚æœä½ é«˜å…´çš„è¯ï¼Œé¡¹ç›®è¿ç§»åˆ° Go1.18 ä¹‹åå¯ä»¥ä½¿ç”¨ä¸‹é¢è¿™è¡Œå‘½ä»¤ç›´æ¥æŠŠæ•´ä¸ªé¡¹ç›®ä¸­çš„ç©ºæ¥å£å…¨éƒ½æ›¿æ¢æˆ anyã€‚å½“ç„¶å› ä¸ºå¹¶ä¸å¼ºåˆ¶ï¼Œæ‰€ä»¥åˆ°åº•æ˜¯ç”¨ `interface{}` è¿˜æ˜¯ `any` å…¨çœ‹è‡ªå·±å–œå¥½

```sh
gofmt -w -r 'interface{} -> any' ./...
```

#### 6. comparable(å¯æ¯”è¾ƒ) å’Œ å¯æ’åº(ordered)

å¯¹äºä¸€äº›æ•°æ®ç±»å‹ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ç±»å‹çº¦æŸä¸­é™åˆ¶åªæ¥å—èƒ½ != å’Œ == å¯¹æ¯”çš„ç±»å‹ï¼Œå¦‚ mapï¼š

```go
// é”™è¯¯ã€‚å› ä¸º map ä¸­é”®çš„ç±»å‹å¿…é¡»æ˜¯å¯è¿›è¡Œ != å’Œ == æ¯”è¾ƒçš„ç±»å‹
type MyMap[KEY any, VALUE any] map[KEY]VALUE
```

æ‰€ä»¥ Go ç›´æ¥å†…ç½®äº†ä¸€ä¸ªå« comparable çš„æ¥å£ï¼Œå®ƒä»£è¡¨äº†æ‰€æœ‰å¯ç”¨ != ä»¥åŠ == å¯¹æ¯”çš„ç±»å‹ï¼š

```go
type MyMap[KEY comparable, VALUE any] map[KEY]VALUE // æ­£ç¡®
```

`comparable` æ¯”è¾ƒå®¹æ˜“å¼•èµ·è¯¯è§£çš„ä¸€ç‚¹æ˜¯å¾ˆå¤šäººå®¹æ˜“æŠŠä»–ä¸å¯æ’åºææ··æ·†ã€‚å¯æ¯”è¾ƒæŒ‡çš„æ˜¯ å¯ä»¥æ‰§è¡Œ `!= ==` æ“ä½œçš„ç±»å‹ï¼Œå¹¶æ²¡ç¡®ä¿è¿™ä¸ªç±»å‹å¯ä»¥æ‰§è¡Œå¤§å°æ¯”è¾ƒï¼ˆ `>,<,<=,>=` ï¼‰ã€‚å¦‚ä¸‹ï¼š

```go
type OhMyStruct struct {
    a int
}

var a, b OhMyStruct

a == b // æ­£ç¡®ã€‚ç»“æ„ä½“å¯ä½¿ç”¨ == è¿›è¡Œæ¯”è¾ƒ
a != b // æ­£ç¡®

a > b // é”™è¯¯ã€‚ç»“æ„ä½“ä¸å¯æ¯”å¤§å°
```

è€Œå¯è¿›è¡Œå¤§å°æ¯”è¾ƒçš„ç±»å‹è¢«ç§°ä¸º `Orderd` ã€‚ç›®å‰ Go è¯­è¨€å¹¶æ²¡æœ‰åƒ `comparable` è¿™æ ·ç›´æ¥å†…ç½®å¯¹åº”çš„å…³é”®è¯ï¼Œæ‰€ä»¥æƒ³è¦çš„è¯éœ€è¦è‡ªå·±æ¥å®šä¹‰ç›¸å…³æ¥å£ï¼Œæ¯”å¦‚æˆ‘ä»¬å¯ä»¥å‚è€ƒ Go å®˜æ–¹åŒ…`golang.org/x/exp/constraints` å¦‚ä½•å®šä¹‰ï¼š

```go
// Ordered ä»£è¡¨æ‰€æœ‰å¯æ¯”å¤§å°æ’åºçš„ç±»å‹
type Ordered interface {
    Integer | Float | ~string
}

type Integer interface {
    Signed | Unsigned
}

type Signed interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Unsigned interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
}

type Float interface {
    ~float32 | ~float64
}
```

> ğŸ’¡ è¿™é‡Œè™½ç„¶å¯ä»¥ç›´æ¥ä½¿ç”¨å®˜æ–¹åŒ… golang.org/x/exp/constraints ï¼Œä½†å› ä¸ºè¿™ä¸ªåŒ…å±äºå®éªŒæ€§è´¨çš„ x åŒ…ï¼Œä»Šåå¯èƒ½ä¼šå‘ç”Ÿéå¸¸å¤§å˜åŠ¨ï¼Œæ‰€ä»¥å¹¶ä¸æ¨èç›´æ¥ä½¿ç”¨

### 3. æ¥å£ä¸¤ç§ç±»å‹

## å¼•ç”¨

[https://segmentfault.com/a/1190000041634906](https://segmentfault.com/a/1190000041634906)
