---
title: 容器技术
date: 2022-08-30 00:00:00
permalink: /pages/faadc3/
categories:
    - 容器
    - 面试题
tags:
    -
author:
    name: brook-w
    link: https://github.com/brook-w
---

## 1. DevOps

### 1.为什么需要 DevOps？

在当今，软件开发公司在软件新版本发布方面，多尝试通过发布一系列以小的
特性改变集为目标的新软件版本，代替发布一个大特性改变集的新软件版本的
方式。这种方式有许多优点，诸如，快速的客户反馈，软件质量的保证等。也
会获得较高的客户满意度评价。

完成这样的软件发布模式，开发公司需要做到：

-   增加软件布署的频率
-   降低新发布版本的失败率
-   缩短修复缺陷的交付时间
-   加快解决版本冲突的问题

DevOps 满足所有这些需求且帮助公司高质完成软件无缝交付的目标

（简单讲就是为了更快的榨干你 懂得都懂:jack_o_lantern:）

### 2.DevOps 有哪些优势？

**技术优势:**

-   持续的软件交付能力

-   修复问题变得简单

-   更快得解决问题

**商业优势:**

-   更快交付的特性
-   更稳定的操作系统环境
-   更多时间可用于创造价值 (而不是修复 / 维护)



### 3.CI 服务有什么用途？

CI （Continuous Integration）-- 持续集成服务

主要用于整合团队开发中不同开发者提交到开发仓库中的项目代码变化，并即时整合编译，检查整合编译错误的服务。它需要一天中多次整合编译代码的能力，若出现整合错误， 可以优异地准确定位提交错误源



## 2.Docker

### 1.Docker 是什么？

Docker 是一个容器化平台，它包装你所有开发环境依赖成一个整体，像一个容器。保证项目开发，如开发、测试、发布等各生产环节都可以无缝工作在不同的平台

Docker 容器：将一个软件包装在一个**完整的文件系统中**，该文件系统包含运行所需的一切：代码，运行时，系统工具，系统库等。可以安装在服务器上的任 何东西

**这保证软件总是运行在相同的运行环境，无需考虑基础环境配置的改变**



### 2.如何使用 Docker 技术创建与环境无关的容器系统？

Docker 技术有三中主要的技术途径辅助完成此需求：

-   存储卷（Volumes）
-   环境变量（Environment variable）注入
-   只读（Read-only）文件系统



### 3.Dockerfile 配置文件中的 COPY 和 ADD 指令有什么不同？

**虽然 ADD 和 COPY 功能相似，推荐 COPY**

COPY 比 ADD 更直观易懂

 COPY 只是将本地文件拷入容器这么简单，而 ADD 有一些其它特性功能（诸如，本地归档解压和支持远程网址访问 等），这些特性在指令本身体现并不明显

因此，有必要使用 ADD 指令的最好例子是需要在本地自动解压归档文件到容器中的情况，如 ADD  rootfs.tar.xz



### 4.Docker 映像（image）是什么？

Docker image 是 Docker 容器的源，Docker images 用于创建 Docker 容器（containers）

映像（Images）通过 Docker build 命令创建， 当 run 映像时，它启动成一个 容器（container）进程

做好的映像由于可能非常庞大，常注册存储在诸如 registry.hub.docker.com 这样的公共平台上

映像常被**分层设计**，每层可单独成为一个小映像，由多层小映像再构成大映像，这样碎片化的设计为了使映像在互联网上共享时，最小化传输数据需求



### 5.Docker 容器（container）是什么？

**Docker containers**

 Docker 容器 是包含其所有运行依赖环境，但与其它容器共享操作系统内核的应用，它运行在独立的主机操作系统用户空间进程中。Docker 容器并不紧密依赖特定的基础平台：可运行在任何配置的计算机， 任何平台以及任何云平台上



### 6.在 Dockerfile 配置文件中最常用的指令有哪些？



一些最常用的指令如下：



-   **FROM**：使用 FROM 为后续的指令建立基础映像。在所有有效的 Dockerfile  中， FROM 是第一条指令。
-    **LABEL**：LABEL 指令用于组织项目映像，模块，许可等。在自动化布署方面 LABEL 也有很大用途。在 LABEL 中指定一组键值对，可用于程序化配置或布署 Docker 。
-    **RUN**：RUN 指令可在映像当前层执行任何命令并创建一个新层，用于在映像层中添加功能层，也许最来的层会依赖它。
-    **CMD**：使用 CMD 指令为执行的容器提供默认值。在 Dockerfile 文件中，若添加多个 CMD 指令，**只有最后的 CMD 指令运行**。

### 7.Docker Image 和 Docker Layer （层) 有什么不同？

**Image**：一个 Docker Image 是由一系列 Docker 只读层（read-only Layer） 创建出来的

**Layer**：在 Dockerfile 配置文件中完成的一条配置指令，即表示一个 Docker  层（Layer）

如下 Dockerfile 文件包含 4 条指令，每条指令创建一个层（Layer）：

```dockerfile
FROM ubuntu:15.04
COPY . /app
RUN make /app
CMD python /app/app.py
```

### 8.在使用 Docker 技术的产品中如何监控其运行？

Docker 在产品中提供如运行统计和 Docker 事件的工具。可以通过这些工具命令获取 Docker 运行状况的统计信息或报告。

-   **Docker stats** ： 通过指定的容器 id 获取其运行统计信息，可获得容器对 CPU，内存使用情况等的统计信息，类似 Linux 系统中的 top 命令。

-   **Docker events** ：Docker 事件是一个命令，用于观察显示运行中的 Docker 一 系列的行为活动。

    >   一般的 Docker 事件有：
    >
    >   -   attach（关联）
    >
    >   -   commit（提交）
    >
    >   -   die（僵死）
    >   -   detach（取消关联）
    >
    >   -   rename（改名）
    >
    >   -   destory（销毁）等
    >   -   也可使用多个选 项对事件记录筛选找到想要的事件信息



### 9.什么是孤儿卷及如何删除它？

<u>孤儿卷是未与任何容器关联的卷</u>

(在 Docker v。1.9 之前的版本中，删除这些 孤儿卷存在很大问题)



### 10. docerfile 配置文件中的 ONBUILD 指令

配置文件中的 ONBUILD 指令为创建的 Docker image （映像）加入在将来执行的指令（译注：在当前配置文件生成的映像中并不执行）， 用于在以这个创建的映像为基础的创建的子映像（image） 中执行或定制。 举例， 以基映像创 建自己的映像时，可定制创建特有的用户化的配置环境。

（以基础映像创建自有的映像过程中，基础映像中所有的创建层或指令是以整体或固化的方式导入自有映像中的，自有映像是不能对这个过程进行自有定制。 而 ONBUILD 指令提供了将某些层从基础映像中剥离出来提供给之后以自有映像为基础映像派生新的映像的可定制途径。这对发布映像而普适在不同的运行环境定制非常有用）



### 11.有没有在有状态性的 Docker 应用的较好实践？ 最适合的场景有什么？

有状态性 Docker 应用的问题关键在于状态数据保存在哪儿的问题。 若所有数据保存在容器内，当更新软件版本或想将 Docker 容器移到其它机器上时，找回这些在运行中产生的状态数据将非常困难。

您需要做的是将这些表达运行状态的数据保存在永久卷中。参考如下 3 种模式：

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/go/interview/image.1aeuob0jkugw.png)

1.   数据保存在容器中，当容器停止运行时，运行状态数据丢失！
2.   数据保存在主机卷（Host Volume）中，当主机停机时，运行状态数据将无法访
3.   数据保存在网络文件系统卷中，数据访问不依赖容器的运行与主机的运行、

如果使用 `docker run -v hostFolder:/containerfolder` 命令运行您的容器， 容器运行中任何对 `/containerfolder` 目录下数据的改变， 将永久保存 在主机的 `hostfolder` 目录下。 使用网络文件系统（nfs）与此类似。 那样就可以运行您的容器在任何主机上且其运行状态数据被保存在网络文件系统 上。

### 12.在 Windows 系统上可以运行原生的 Docker 容器吗？

在 'Windows Server 2016' 系统上， 你可以运行 Windows 的原生容器， 微软推出其映像是 'Windows Nano Server' ， 一个轻量级的运行在容器中的 Windows 原生系统。 您可以在其中布署基于 .NET 的应用。

（怎么说呢，没啥用 —— 因为你要依赖于 .Net 或者 SqlServer 来构建应用，它们已经支持容器化部署（.Net On Docker，SqlServer On Docker），何必在 Windows 上运行 Docker ）



## 3.虚拟化

### 1.虚拟化技术是什么？

最初的构想，`virtualisation`（虚拟化） 被认为是逻辑划分大型主机使得多个应用可以并行运行的一种技术方案。然而，随着技术公司及开源社区的推进， 现实发生了戏剧性的转变，以致产生了以一种或某种方式操作特权指令可以在 单台基于 x86 硬件的系统上同时运行多个（种）操作系统的技术。



实质的效果是，虚拟化技术允许你在一个硬件平台下运行 2 个完全不同的操作系统。每个客户操作系统可完成像系统自检、启动、载入系统内核等像在独立硬件上的一切动作。同时也具备坚实的安全基础，例如，客户操作系统不能获取完全访问主机或其它客户系统的权限，及其它涉及安全，可能把系统搞坏的操作。



基于对客户操作系统虚拟硬件、运行环境模拟方法的不同，对虚拟化技术进行分类，主要的有如下 3 种虚拟化技术种类：

-   全模拟（Emulation）
-   半虚拟（Paravirtualization）
-   基于容器的虚拟化（Container-based virtualization）



### 2.什么是半虚拟化（Paravirtualization）?

Paravirtualization，也称为第 1 类虚拟机管理（层）程序，其直接在硬件或裸机（bare-metal）上运行，提供虚拟机直接使用物理硬件的服务，它帮助主机操作系统，虚拟化硬件和实际硬件进行协作以实现最佳性能。这种虚拟层管理技术的程序一般占用系统资源较小，其本身并不需要占用大量系统资源。

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/go/interview/image.5s1abzed3ck0.png)

这种虚拟层管理程序有 Xen, KVM,VMware 等。



### 3.Docker 技术与虚拟机技术有何不同？

Docker 不是严格意义上的虚拟化硬件的技术。

它依赖 container-based  virtualization（基于容器的虚拟化） 的技术实现工具，或可以认为它是操作系统用户运行级别的虚拟化。因此，Docker 最初使用 LXC 驱动它，后来移至 由 libcontainer 基础库驱动它，现已更名为 runc 。

Docker 主要致力于应用容器内的应用程序的自动化部署。

应用容器设计用于包装和运行单一服务， 而操作系统设计用于运行多进程任务，提供多种运算服务的能力。如虚拟机中等同完全操作系统的能力。

因此，Docker 被认为是容器化系统上管理容器及应用容器化的布署工具。

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/go/interview/image.7e36ofb4i2c0.png)

-   与虚拟机不同，容器无需启动操作系统内核，因此，容器可在不到 1 秒钟时间内运行起来。这个特性，使得容器化技术比其它虚拟化技术更具有独特性及可取性。
-   由于容器化技术很少或几乎不给主机系统增加负载，因此，基于容器的虚拟化技术具有近乎原生的性能表现。
-   基于容器的虚拟化，与其他硬件虚拟化不同，运行时不需要其他额外的虚拟管理层软件。
-   主机上的所有容器共享主机操作系统上的进程调度，从而节省了额外的资源的需求。
-   与虚拟机 image 相比，容器（Docker 或 LXC images）映像较小， 因此，容器映像易于分发。
-   容器中的资源分配由 Cgroups 实现。 Cgroup 不会让容器占用比给它们分配的更多的资源。但是，现在其它的虚拟化技术，对于虚拟机，主机的所有资源都可见，但无法使用。这可以通过在容器和主机上同时运行 top 或 htop 来观察到。在两个环境中的输出看起来相同。



## 4.容器化技术



### 1.容器化技术在底层的运行原理

2006 年前后， 人们，包括一些谷歌的雇员， 在 Linux 内核级别上实现了一 种新的名为命名空间（namespace） 的技术（实际上这种概念在 FreeBSD 系统上由来已久）。

我们知道，操作系统的一个功能就是进程共享公共资源， 诸如，网络和硬盘空间等。 但是，如果一些公共资源被包装在一个命名空间中， 只允许属于这个命名空间中的进程访问又如何呢？ 也就是说，可以分配一大块硬盘空间给命名空间 X 供其使用，但是，命名空间 Y 中的进程无法看到或访问这部分资源。 同样地， 命名空间 Y 中分配的资源，命名空间 X 中的进程也无法访问。当然， X 中的进程无法与 Y 中的进程进行交互。这提供了某种对公共资源的虚拟化和隔离的技术。



这就是 Docker 技术的底层工作原理：

>   每个容器运行在它自己的命名空间中， 但是，确实与其它运行中的容器共用相同的系统内核。 隔离的产生是由于系统内核清楚地知道命名空间及其中的进程，且这些进程调用系统 API 时，内核保 证进程只能访问属于其命名空间中的资源。

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/go/interview/image.3kyeav28zsg0.png)



运行中的容器是隔离的。准确地说，各容器共享操作系统内核及操作系统 API。



### 2.说说容器化技术与虚拟化技术的优缺点

不能像虚拟机那样在容器上运行与主机完全不同的操作系统。 然而， 可以在容器上运行不同的 Linux 发布版，由于容器共享系统内核的缘故。容器的隔离性没有虚拟机那么健壮。

事实上， 在早期容器化技术实现上，存在某种方法使客户容器可接管整个主机系统。 也可看到，载入新容器并运行，并不会像虚拟机那样装载一个新的操作系统进来。

所有的容器共享同一系统内核， 这也就是容器被认为非常轻量化的原因。

同样的原因，不像虚拟机，你不须为容器预分配大量的内存空间， 因为它不是运行新的整个的操作系统。 这使得在一个操作系统主机上，可以同时运行成 百上千个容器应用， 在运行完整操作系统的虚拟机上，进行这么多的并行沙箱实验是不可能的。



## 5.Docker compose

### 1.为什么 Docker compose 采取的是并不等待前面依赖服务项的容器启动就绪后再启动的组合容器启动策略？

Docker 的 Compose 配置总是以依赖启动序列来启动或停止 Compose 中的服务容器， 依赖启动序列是由 Compose 配置文件中的 depends_on ， links ， volumes_from 和 network_mode: "service : ..." 等这些配置指令所确定的。

然而， Compose 启动中， 各容器的启动并不等待其依赖容器（这必定是你整个应用中的某个依赖的服务或应用）启动就绪后才启动。使用这种策略较好的，理由如下:

>   等待一个数据库服务（举例）就绪这样的问题， 在大型分布式系统中仅是相比其它大问题的某些小问题。 在实际发布产品运维中， 您的数据库服务会由于各种原因，或者迁移宿主机导致其不可访问。 您发布的产品需要有应对这样状况的弹性。

掌控这些，在开发设计您的应用， 使其在访问数据库失效的情况下， 能够试图重连数据库， 直至其连接到数据库为止。

最佳的解决方案是在您的应用代码中检查是否有应对意外的发生，无论是任何原因导致的启动或连接失效都应考虑在内。



































