---
title: 3. 主查询
date: 2022-03-03 00:00:00
permalink: /pages/4a956c/
categories:
  - 数据库
  - MySQL
tags:
  - 
author: 
  name: brook-w
  link: https://github.com/brook-w
---

## 1. 基础部分
### 1. SELECT 
#### 1 SELECT ...
```sql
SELECT 1; #没有任何子句 SELECT 9/2; #没有任何子句
```
#### 2. SELECT ... FROM
```sql
SELECT 
  标识选择哪些列 
FROM 
  标识从哪个表中选择

-- 选择全部列
SELECT * FROM departments;
```
::: tip
一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节
省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通
配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。

在生产环境下，不推荐你直接使用 SELECT * 进行查询。
:::

- 选择特定的列
```sql
SELECT
  department_id,location_id 
FROM 
  departments;
```
#### 3. 列的别名

- 重命名一个列
- 便于计算
- 紧跟列名，也可以在列名和别名之间加入关键字AS，别名使用双引号，以便在别名中包含空格或特殊的字符并区分大小写。
- AS可以省略
- 建议别名简短，见名知意

```sql
SELECT 
  last_name AS name,commission_pct comm 
FROM
   employees;

SELECT
  last_name "Name",salary*12 "AnnualSalary" 
FROM 
  employees;
```

#### 4 去除重复行 DISTINCT
```sql
SELECT DISTINCT department_id FROM employees;
```

```sql
SELECT DISTINCT department_id,salary FROM employees;
```
- DISTINCT 需要放到所有列名的前面
- DISTINCT 其实是对后面所有列名的组合进行去重

#### 5. 空值参与运算

- 所有运算符或列值遇到null值，运算的结果都为null

```sql
SELECT 
employee_id, salary, commission_pct, 12 * salary * (1 + commission_pct) "annual_sal" 
FROM employees;
```
:::theorem 注意
在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长
度是空。而且，在 MySQL 里面，空值是占用空间的
:::

#### 6. 着重号

- 错误的
```
mysql> SELECT * FROM ORDER; 
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'ORDER' at line 1
```

- 正确的
```sql
SELECT * FROM `ORDER`;
SELECT * FROM `order`;
```

我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在
SQL语句中使用一对``（着重号）引起来

#### 7. 查询常数

`SELECT` 查询还可以对常数进行查询。对的，就是在 `SELECT` 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的

作用：SQL 中的 `SELECT` 语法提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数

比如说，我们想对 `employees` 数据表中的员工姓名进行查询，同时增加一列字段 `corporation` ，这个字段固定值为“你好SQL”，可以这样写

```sql
SELECT '你好SQL' as corporation, last_name FROM employees;
```


#### 9. 过滤数据 WHERE
```sql
SELECT 字段1,字段2 FROM 表名 WHERE 过滤条件

SELECT 
  employee_id, last_name, job_id, department_id 
FROM 
    employees 
WHERE 
  department_id = 90;
```


### 2. 运算符
#### 1. 算术运算符

算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加
（+）、减（-）、乘（*）、除（/）和取模（%）运算

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.18xvmets8g68.jpg)


1. 加法与减法运算符
```sql
SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5 FROM dual;

+-----+---------+---------+----------+--------------+------------+------------+ 
| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 | 
+-----+---------+---------+----------+--------------+------------+------------+ 
| 100 | 100     | 100     | 150      | 120          | 135.5      | 64.5       | 
+-----+---------+---------+----------+--------------+------------+------------+ 
1 row in set (0.00 sec)
```

由运算结果可以得出如下结论：

:::tip
- 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；
- 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；
- 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；
- 在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL中字符串拼接要使用字符串函数`CONCAT()`实现）
:::


2. 乘法与除法运算符

```sql
SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100 DIV 0 FROM dual;

+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+
| 100 | 100 * 1 | 100 * 1.0 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 | 100 /3 | 100 DIV 0 | 
+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+
| 100 | 100     | 100.0     | 100.0000  | 50.0000 | 105.0000        | 33.3333 | NULL     | 
+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+
1 row in set (0.00 sec)
```

```sql
#计算出员工的年基本工资 
SELECT employee_id,salary,salary * 12 annual_sal FROM employees;
```

由运算结果可以得出如下结论：
:::tip
- 一个数乘以整数1和除以整数1后仍得原数；
- 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等
- 一个数除以整数后，不管是否能除尽，结果都为一个浮点数
- 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位
- 乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同
- 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL
:::

3. 求模（求余）运算符 将表中的字段i对3和5进行求模（求余）运算

```sql
SELECT 12 % 3, 12 MOD 5 FROM dual;
+--------+----------+
| 12 % 3 | 12 MOD 5 |
+--------+----------+
| 0      | 2        | 
+--------+----------+
1 row in set (0.00 sec)

#筛选出employee_id是偶数的员工
SELECT * FROM employees WHERE employee_id MOD 2 = 0;
```

#### 2. 比较运算符

比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果
为假则返回0，其他情况则返回NULL


![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.1ztvlxcflmf4.jpg)


非符号类型的运算符:
| 运算符      | 名称             | 作用                                   | 示例                                        |
| ----------- | ---------------- | -------------------------------------- | ------------------------------------------- |
| IS NULL     | 为空运算符       | 判断值、字符串或者表达式的值是否为空   | SELECT B FROM TABLE WHERE A IS NULL         |
| IS NOTNULL  | 不为空运算符     | 判断值、字符串或者表达式的值是否不为空 | SELECT B FROM TABLE WHERE A IS NOTNULL      |
| LEAST       | 最小值运算符     | 在多个值中返回最小值                   | SELECT D FROM TABLE WHERE C LEAST (A,B)     |
| GREATEST    | 最大值运算符     | 在多个值中返回最大值                   | SELECT D FROM TABLE WHERE C GREATEST (A,B)  |
| BETWEEN AND | 两值之间的运算符 | 判断一个值是否在两值中间               | SELECT D FROM TABLE WHERE C BETWEEN A AND B |
| ISNULL      | 为空运算符       | 判断值、字符串或者表达式的值是否为空   | SELECT B FROM TABLE WHERE A ISNULL          |
| IN          | 属于运算符       | 判断一个值是否为列表中的任意一个值     | SELECT D FROM TABLE WHERE C IN (A,B)        |
| NOT IN      | 不属于运算符     | 判断一个值是否不是列表中的任意一个值   | SELECT D FROM TABLE WHERE C NOT IN (A,B)    |
| LIKE        | 模糊匹配运算符   | 判断一个值是否符合模糊匹配规则         | SELECT C FROM TABLE WHERE A LIKE B          |
| REGEEXP     | 正则表达式运算符 | 判断一个值是否符合正则表达式的规则     | SELECT C FROM TABLE WHERE A REGEEXP B       |
| RLIKE       | 正则表达式运算符 | 判断一个值是否符合正则表达式的规则     | SELECT C FROM TABLE WHERE A RLIKE B         |


1. 等号运算符

- 等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回
0

- 在使用等号运算符时，遵循如下规则
  - 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的
是每个字符串中字符的ANSI编码是否相等
  - 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小
  - 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较
  - 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL

```sql
SELECT 1 = 1, 1 = '1', 1 = 0, 'a' = 'a', (5 + 3) = (2 + 6), '' = NULL , NULL = NULL;
+-------+---------+-------+-----------+-------- -----------+-----------+------------+
| 1 = 1 | 1 = '1' | 1 = 0 | 'a' = 'a' | (5 + 3)= (2 + 6) | '' = NULL | NULL = NULL  | 
+-------+---------+-------+-----------+-------------------+-----------+-------------+
| 1     | 1       | 0     | 1         | 1                 | NULL      | NULL        | 
+-------+---------+-------+-----------+-------------------+-----------+-------------+
```

```sql
SELECT 1 = 2, 0 = 'abc', 1 = 'abc' FROM dual;
+-------+-----------+-----------+
| 1 = 2 | 0 = 'abc' | 1 = 'abc' |
+-------+-----------+-----------+
| 0     | 1         | 0         | 
+-------+-----------+-----------+
```

```sql
#查询salary=10000，注意在Java中比较是== 
SELECT employee_id,salary FROM employees WHERE salary = 10000;
```

2. 安全等于运算符

安全等于运算符（<=>）与等于运算符（=）的作用是相似的， 唯一的区别 `是‘<=>’可以用来对NULL进行判断`。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL

```sql
SELECT 1 <=> '1', 1 <=> 0, 'a' <=> 'a', (5 + 3) <=> (2 + 6), '' <=> NULL,NULL <=> NULL FROM dual;
+-----------+---------+-------------+---------------------+-------------+---------------+
| 1 <=> '1' | 1 <=> 0 | 'a' <=> 'a' | (5 + 3) <=> (2 + 6) | '' <=> NULL | NULL <=> NULL | 
+-----------+---------+-------------+---------------------+-------------+---------------+
| 1         | 0       | 1           | 1                   | 0           | 1             | 
+-----------+---------+-------------+---------------------+-------------+---------------+
```

```sql
#查询commission_pct等于0.40
SELECT employee_id,commission_pct FROM employees WHERE commission_pct = 0.40;
SELECT employee_id,commission_pct FROM employees WHERE commission_pct <=> 0.40;
```

可以看到，使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为1而不是NULL，其他
返回结果与等于运算符相同

3. 不等于运算符

不等于运算符（<>和!=）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL

```sql
SELECT 1 <> 1, 1 != 2, 'a' != 'b', (3+4) <> (2+6), 'a' != NULL, NULL <> NULL;
+--------+--------+------------+----------------+-------------+--------------+
| 1 <> 1 | 1 != 2 | 'a' != 'b' | (3+4) <> (2+6) | 'a' != NULL | NULL <> NULL | 
+--------+--------+------------+----------------+-------------+--------------+
| 0      | 1      | 1          | 1              | NULL        | NULL         | 
+--------+--------+------------+----------------+-------------+--------------+
```


4. 空运算符

空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回

```sql
 SELECT NULL IS NULL, ISNULL(NULL), ISNULL('a'), 1 IS NULL;
+--------------+--------------+-------------+-----------+
| NULL IS NULL | ISNULL(NULL) | ISNULL('a') | 1 IS NULL | +--------------+--------------+-------------+-----------+
| 1            | 1            | 0           | 0         | 
+--------------+--------------+-------------+-----------+
 ```

 ```sql
# 查询commission_pct等于NULL。比较如下的四种写法
SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL; 
SELECT employee_id,commission_pct FROM employees WHERE commission_pct <=> NULL; 
SELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct); 
SELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL;
# 判断某一字段为空
SELECT last_name, manager_id FROM employees WHERE manager_id IS NULL;
```

5. 非空运算符

非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0

```sql
SELECT NULL IS NOT NULL, 'a' IS NOT NULL, 1 IS NOT NULL;
+------------------+-----------------+---------------+
| NULL IS NOT NULL | 'a' IS NOT NULL | 1 IS NOT NULL | 
+------------------+-----------------+---------------+
| 0                | 1               | 1             | 
+------------------+-----------------+---------------+
```

```sql
#查询commission_pct不等于NULL 
SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NOT NULL; 
SELECT employee_id,commission_pct FROM employees WHERE NOT commission_pct <=> NULL; 
SELECT employee_id,commission_pct FROM employees WHERE NOT ISNULL(commission_pct);
```

6. 最小值运算符

语法格式为：LEAST(值1，值2，...，值n)。其中，“值n”表示参数列表中有n个值在有两个或多个参数的情况下，返回最小值

```sql
SELECT LEAST (1,0,2), LEAST('b','a','c'), LEAST(1,NULL,2);
+---------------+--------------------+-----------------+
| LEAST (1,0,2) | LEAST('b','a','c') | LEAST(1,NULL,2) | 
+---------------+--------------------+-----------------+
| 0             | a                  | NULL            | 
+---------------+--------------------+-----------------+
```

由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。

7. 最大值运算符
语法格式为：GREATEST(值1，值2，...，值n)。其中，“值n”表示参数列表中有n个值在有两个或多个参数的情况下，返回最大值。假如任意一个自变量为NULL，GREATEST()的返回值为NULL。

```sql
SELECT GREATEST(1,0,2), GREATEST('b','a','c'), GREATEST(1,NULL,2);
+-----------------+-----------------------+--------------------+
| GREATEST(1,0,2) | GREATEST('b','a','c') | GREATEST(1,NULL,2) |
+-----------------+-----------------------+--------------------+
| 2               | c                     | NULL               | 
+-----------------+-----------------------+--------------------+
```

由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL

8. BETWEEN AND运算符

BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0

```sql
SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, 'b' BETWEEN 'a' AND 'c';
+-------------------+----------------------+-------------------------+
| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | 'b' BETWEEN 'a' AND 'c' | 
+-------------------+----------------------+-------------------------+
| 1                 | 0                    | 1                       | 
+-------------------+----------------------+-------------------------+

SELECT last_name, salary FROM employees WHERE salary BETWEEN 2500 AND 3500;
```

9. IN运算符

IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给
定的值为NULL，或者IN列表中存在NULL，则结果为NULL

```sql
SELECT 'a' IN ('a','b','c'), 1 IN (2,3), NULL IN ('a','b'), 'a' IN ('a', NULL);
+----------------------+------------+-------------------+--------------------+
| 'a' IN ('a','b','c') | 1 IN (2,3) | NULL IN ('a','b') | 'a' IN ('a', NULL) | 
+----------------------+------------+-------------------+--------------------+
| 1                    | 0          | NULL              | 1                  | 
+----------------------+------------+-------------------+--------------------+

SELECT 
  employee_id, last_name, salary, manager_id 
FROM 
  employees 
WHERE manager_id IN (100, 101, 201);
```

10. NOT IN运算符

NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一
个值，则返回1，否则返回0

```sql
SELECT 'a' NOT IN ('a','b','c'), 1 NOT IN (2,3);
+--------------------------+----------------+
| 'a' NOT IN ('a','b','c') | 1 NOT IN (2,3) | 
+--------------------------+----------------+
| 0                        | 1              | 
+--------------------------+----------------+
```

11. LIKE运算符

LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回
0。如果给定的值或者匹配条件为NULL，则返回结果为NULL

LIKE运算符通常使用如下通配符

- `%`：匹配0个或多个字符
- `_`：只能匹配一个字符

```sql
SELECT NULL LIKE 'abc', 'abc' LIKE NULL;
+-----------------+-----------------+
| NULL LIKE 'abc' | 'abc' LIKE NULL | 
+-----------------+-----------------+
| NULL            | NULL            | 
+-----------------+-----------------+
```

```sql
SELECT first_name FROM employees WHERE first_name LIKE 'S%';
```

```sql
SELECT last_name FROM employees WHERE last_name LIKE '_o%';
```

**ESCAPE**

- 回避特殊符号的：使用转义符。例如：将[%]转为[$%]、[]转为[$]，然后再加上[ESCAPE‘$’]即可

```sql
SELECT job_id FROM jobs WHERE job_id LIKE 'IT\_%';
```

- 如果使用\表示转义，要省略ESCAPE。如果不是\，则要加上ESCAPE

```sql
SELECT job_id FROM jobs WHERE job_id LIKE 'IT$_%' escape '$';
```

12. REGEXP运算符

REGEXP运算符用来匹配字符串，语法格式为： `expr REGEXP 匹配条件`

如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL

REGEXP运算符在进行匹配时，常用的有下面几种通配符:

> 1. '^' 匹配以该字符后面的字符开头的字符串
> 2. '$' 匹配以该字符前面的字符结尾的字符串
> 3. '.' 匹配任何一个单字符
> 4. "[...]"匹配在方括号内的任何字符。例如，"[abc]" 匹配 "a" 或 "b" 或 "c"。为了命名字符的范围，使用一 个'-'。"[a-z]" 匹配任何字母，而 "[0-9]" 匹配任何数字
> 5. '\*' 匹配零个或多个在它前面的字符。例如，"x*" 匹配任何数量的 'x' 字符，"[0-9]\*" 匹配任何数量的数字,而 "*" 匹配任何数量的任何字符

```sql
SELECT 'shkstart' REGEXP '^s', 'shkstart' REGEXP 't$', 'shkstart' REGEXP 'hk';
+------------------------+------------------------+-------------------------+
| 'shkstart' REGEXP '^s' | 'shkstart' REGEXP 't$' | 'shkstart' REGEXP 'hk'  | 
+------------------------+------------------------+-------------------------+
| 1                      | 1                      | 1                       | 
+------------------------+------------------------+-------------------------+
```

#### 3. 逻辑运算符

逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。 MySQL中支持4种逻辑运算符如下:

| 运算符    | 作用     | 示例                               |
| --------- | -------- | ---------------------------------- |
| NOT 或 ！ | 逻辑非   | SELECT NOT A                       |
| AND 或 && | 逻辑与   | SELECT  A AND B <br> SELECT A && B |
| OR 或     |          |                                    | 逻辑或 | SELECT  A OR B <br> SELECT A |  | B |
| XOR       | 逻辑异或 | SELECT  A XOR B                    |

1. 逻辑非运算符

逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；
当给定的值为NULL时，返回NULL

```sql
SELECT NOT 1, NOT 0, NOT(1+1), NOT !1, NOT NULL;
+-------+-------+----------+--------+----------+
| NOT 1 | NOT 0 | NOT(1+1) | NOT !1 | NOT NULL | 
+-------+-------+----------+--------+----------+
| 0     | 1     | 0        | 1      | NULL     | 
+-------+-------+----------+--------+----------+

SELECT last_name, job_id FROM employees WHERE job_id NOT IN ('IT_PROG', 'ST_CLERK', 'SA_REP');
```

2. 逻辑与运算符 

逻辑与（AND或&&）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL

```sql
SELECT 1 AND -1, 0 AND 1, 0 AND NULL, 1 AND NULL;
+----------+---------+------------+------------+
| 1 AND -1 | 0 AND 1 | 0 AND NULL | 1 AND NULL | 
+----------+---------+------------+------------+
| 1        | 0       | 0          | NULL       | 
+----------+---------+------------+------------+
```

```sql
SELECT employee_id, last_name, job_id, salary FROM employees WHERE salary >=10000 AND job_id LIKE '%MAN%';
```

3. 逻辑或运算符

逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。

```sql
SELECT 1 OR -1, 1 OR 0, 1 OR NULL, 0 || NULL, NULL || NULL;
+---------+--------+-----------+-----------+--------------+
| 1 OR -1 | 1 OR 0 | 1 OR NULL | 0 || NULL | NULL || NULL | 
+---------+--------+-----------+-----------+--------------+
| 1       | 1      | 1         | NULL      | NULL         | 
+---------+--------+-----------+-----------+--------------+

#查询基本薪资不在9000-12000之间的员工编号和基本薪资
SELECT employee_id,salary 
FROM employees 
WHERE NOT (salary >= 9000 AND salary <= 12000);

SELECT employee_id,salary 
FROM employees 
WHERE salary <9000 OR salary > 12000;

SELECT employee_id,salary 
FROM employees 
WHERE salary NOT BETWEEN 9000 AND 12000;

SELECT employee_id, last_name, job_id, salary 
FROM employees 
WHERE salary >= 10000 OR job_id LIKE '%MAN%';
```

4. 逻辑异或运算符

逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1

```sql
SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0;
+----------+---------+---------+------------+---------------+---------------+
| 1 XOR -1 | 1 XOR 0 | 0 XOR 0 | 1 XOR NULL | 1 XOR 1 XOR 1 | 0 XOR 0 XOR 0 | 
+----------+---------+---------+------------+---------------+---------------+
| 0        | 1       | 0       | NULL       | 1             | 0             | 
+----------+---------+---------+------------+---------------+---------------+

SELECT last_name,department_id,salary
FROM employees 
WHERE department_id IN (10,20) XOR salary > 8000;
```

#### 4. 位运算符

位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数

MySQL支持的位运算符如下:
| 运算符 | 作用     | 示例         |
| ------ | -------- | ------------ |
| &      | 按位与   | SELECT A & B |
|        |          | 按位或       | SELECT A | B |
| ^      | 按位异或 | SELECT A ^ B |
| ~      | 按位取反 | SELECT A ~ B |
| >>     | 按位右移 | SELECT A >>2 |
| <<     | 按位左移 | SELECT A<< 2 |

1. 按位与运算符

按位与（&）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二
进制位的数值都为1时，则该位返回1，否则返回0

```sql
> SELECT 1 & 10, 20 & 30;
+--------+---------+
| 1 & 10 | 20 & 30 | 
+--------+---------+
| 0      | 20      | 
+--------+---------+
```

1的二进制数为0001，10的二进制数为1010，所以1 & 10的结果为0000，对应的十进制数为0。

20的二进制数为10100，30的二进制数为11110，所以20 & 30的结果为10100，对应的十进制数为20。

2. 按位或运算符

按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的
二进制位的数值有一个或两个为1时，则该位返回1，否则返回0

```sql
SELECT 1 | 10, 20 | 30;
+--------+---------+
| 1 | 10 | 20 | 30 | 
+--------+---------+
| 11     | 30      | 
+--------+---------+
```

1的二进制数为0001，10的二进制数为1010，所以1 | 10的结果为1011，对应的十进制数为11。

20的二进制数为10100，30的二进制数为11110，所以20 | 30的结果为11110，对应的十进制数为30

3. 按位异或运算符

按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值
对应的二进制位的数值不同时，则该位返回1，否则返回0

```sql
SELECT 1 ^ 10, 20 ^ 30;
+--------+---------+
| 1 ^ 10 | 20 ^ 30 | 
+--------+---------+
| 11     | 10      | 
+--------+---------+
```
1的二进制数为0001，10的二进制数为1010，所以1 ^ 10的结果为1011，对应的十进制数为11。

20的二进制数为10100，30的二进制数为11110，所以20 ^ 30的结果为01010，对应的十进制数为10。

```sql
SELECT 12 & 5, 12 | 5,12 ^ 5 FROM DUAL;
+--------+--------+--------+
| 12 & 5 | 12 | 5 | 12 ^ 5 | 
+--------+--------+--------+
| 4      | 13     | 9      | 
+--------+--------+--------+
```

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.6cnb7z5rn0w0.jpg)


4. 按位取反运算符

```sql
SELECT 10 & ~1;
+---------+
| 10 & ~1 | 
+---------+
| 10      | 
+---------+
```

由于按位取反（~）运算符的优先级高于按位与（&）运算符的优先级，所以10 & ~1，首先，对数字1进行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。

5. 按位右移运算符

```sql
SELECT 1 >> 2, 4 >> 2;
+--------+--------+
| 1 >> 2 | 4 >> 2 | 
+--------+--------+
| 0      | 1      | 
+--------+--------+
```

1的二进制数为0000 0001，右移2位为0000 0000，对应的十进制数为0。4的二进制数为0000 0100，右移2
位为0000 0001，对应的十进制数为1

6. 按位左移运算符

```sql
SELECT 1 << 2, 4 << 2;
+--------+--------+
| 1 << 2 | 4 << 2 |
+--------+--------+
| 4      | 16     | 
+--------+--------+
```

1的二进制数为0000 0001，左移两位为0000 0100，对应的十进制数为4。4的二进制数为0000 0100，左移两位为0001 0000，对应的十进制数为16


#### 5. 运算符的优先级

| 优先级 | 运算符                                   |
| ------ | ---------------------------------------- |
| 1      | :=，=(赋值)                              |
| 2      | \|\|,OR,XOR                              |
| 3      | &&,AND                                   |
| 4      | NOT                                      |
| 5      | BETWEEN,CASE,WHERE,THEN,ELSE             |
| 6      | =,<=>,>=,>,<=,<,<>,!=,IS,LIKE,REGEEXP,IN |
| 7      | \|                                       |
| 8      | &                                        |
| 9      | <<，>>                                   |
| 10     | -,+                                      |
| 11     | \*,/.DIV,%,MOD                           |
| 12     | ^                                        |
| 13     | -(负号),~                                |
| 14     | !                                        |
| 15     | ()                                       |

数字编号越大，优先级越高，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使用 "()" 括起来的表达式的优先级最高


### 3. 排序与分页

#### 1. 排序

##### 1. 排序数据

- 使用 ORDER BY 子句排序
  - ASC（ascend）: 升序
  - DESC（descend）:降序
- ORDER BY 子句在SELECT语句的结尾

##### 2. 单列排序

```sql
SELECT last_name, job_id, department_id, hire_date 
FROM employees 
ORDER BY hire_date;

SELECT last_name, job_id, department_id, hire_date 
FROM employees 
ORDER BY hire_date DESC ;

SELECT employee_id, last_name, salary*12 annsal 
FROM employees 
ORDER BY annsal;
```

##### 3. 多列排序

```sql
SELECT last_name, department_id, salary 
FROM employees 
ORDER BY department_id, salary DESC;
```

- 可以使用不在SELECT列表中的列排序
- 在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第
一列数据中所有值都是唯一的，将不再对第二列进行排序

#### 2. 分页

##### 1. 实现规则

- MySQL中使用 LIMIT 实现分页 -- `LIMIT [位置偏移量,] 行数`

```sql
--前10条记录： 
SELECT * FROM 表名 LIMIT 0,10; 
-- 或者
SELECT * FROM 表名 LIMIT 10;
--第11至20条记录： 
SELECT * FROM 表名 LIMIT 10,10;
--第21至30条记录： 
SELECT * FROM 表名 LIMIT 20,10;
```
:::tip
MySQL 8.0中可以使用 "LIMIT 3 OFFSET 4"，意思是获取从第5条记录开始后面的3条记录，和 "LIMIT 4,3" 返回的结果相同
:::

- 分页显式公式：`（当前页数-1）*每页条数，每页条数`

```sql
SELECT * FROM table LIMIT(PageNo - 1)*PageSize,PageSize;
```

- 注意：LIMIT 子句必须放在整个SELECT语句的最后！

使用 LIMIT 的好处：
> 约束返回结果的数量可以 减少数据表的网络传输量 ，也可以 提升查询效率 。如果我们知道返回结果只有1 条，就可以使用 LIMIT 1 ，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需
要扫描完整的表，只需要检索到一条符合条件的记录即可返回

##### 2. 拓展

在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关
键字，而且需要放到 SELECT 语句的最后面

- 如果是 SQL Server 和 Access，需要使用 TOP 关键字，比如：

```sql
SELECT TOP 5 name, hp_max FROM heros ORDER BY hp_max DESC
```

- 如果是 Oracle，你需要基于 ROWNUM 来统计行数

```sql
SELECT rownum,last_name,salary FROM employees WHERE rownum < 5 ORDER BY salary DESC;

-- 改进版
SELECT rownum, last_name,salary 
FROM (
  SELECT last_name,salary FROM employees ORDER BY salary DESC
) WHERE rownum < 10;
```

### 4. 多表查询

多表查询，也称为关联查询，指两个或更多个表一起完成查询操作

#### 1. 多表连接案例

1. 多表连接案例

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.2r4ue289e8a0.jpg)

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.5ghrogqak640.jpg)

```sql
# 案例：查询员工的姓名及其部门名称
SELECT last_name, department_name FROM employees, departments;
```

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.wpqsmbkeo4g.jpg)

查询结果：

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.6yevz6gunvw0.jpg)

**分析错误情况：**

```sql
SELECT COUNT(employee_id) FROM employees; 
#输出107行 
SELECT COUNT(department_id)FROM departments; 
#输出27行 
SELECT 107*27 FROM dual;
```

**结果：笛卡尔积的错误**

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.29nk6pjoun0g.jpg)


2. 解决

- 笛卡尔积的错误会在下面条件下产生：
  - 省略多个表的连接条件（或关联条件）
  - 连接条件（或关联条件）无效
  - 所有表中的所有行互相连接
- 为了避免笛卡尔积， `可以在 WHERE 加入有效的连接条件`
```sql
#案例：查询员工的姓名及其部门名称 
SELECT last_name, department_name 
FROM employees, departments 
WHERE employees.department_id = departments.department_id;
```
- 在表中有相同列时，在列名之前加上表名前缀

#### 2. 多表查询分类讲解

##### 1. 等值连接 vs 非等值连接

**等值连接**

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.5qy3jec7odc0.jpg)

```sql
SELECT 
  employees.employee_id, 
  employees.last_name, 
  employees.department_id, 
  departments.department_id, 
  departments.location_id 
FROM employees, departments 
WHERE employees.department_id = departments.department_id;
```

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.6iceu926z6o0.jpg)

- 拓展1：多个连接条件与 AND 操作符
- 拓展2：区分重复的列名
- 拓展3：表的别名
```sql
SELECT e.employee_id, e.last_name, e.department_id, d.department_id, d.location_id 
FROM employees e , departments d 
WHERE e.department_id = d.department_id
```
:::warning 注意
如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，
不能使用原有的表名，否则就会报错
:::

:::tip 阿里JAVA开发规范
【 强制 】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或
表名）进行限定。
<br><br>
说明 ：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表
名），并且操作列在多个表中存在时，就会抛异常
<br><br>
正例 ：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;
<br><br>
反例 ：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年
后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出
1052 异常：Column 'name' in field list is ambiguous
:::

- 拓展4：连接多个表 —— **连接 n个表,至少需要n-1个连接条件**

**非等值连接**

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.3ox9nyqlrmg0.jpg)

```sql
SELECT e.last_name, e.salary, j.grade_level 
FROM employees e, job_grades j 
WHERE e.salary BETWEEN j.lowest_sal AND j.highest_sal
```

##### 2. 自连接 vs 非自连接

**自连接**

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.6r20q12gp4w0.jpg)

- 当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两
个表再进行内连接，外连接等查询

- 查询employees表，返回“Xxx works for Xxx”

```sql
SELECT CONCAT(worker.last_name ,' works for ' , manager.last_name) 
FROM employees worker, employees manager 
WHERE worker.manager_id = manager.employee_id;
```

##### 3. 内连接 vs 外连接

除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.4i8wfst9q0m0.jpg)

- `内连接`: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行
- `外连接`: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的
行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)
  - 如果是`左外连接`，则连接条件中左边的表也称为 `主表` ，右边的表称为 `从表`
  - 如果是`右外连接`，则连接条件中右边的表也称为 `主表` ，左边的表称为 `从表`

#### 3. SQL99语法实现多表查询

##### 1. 基本语法

- 使用JOIN...ON子句创建连接的语法结构：
```sql
SELECT 
  table1.column, table2.column,table3.column 
FROM 
  table1 
JOIN table2 ON table1 和 table2 的连接条件 
JOIN table3 ON table2 和 table3 的连接条件
```

- 语法说明
  - `可以使用 ON 子句指定额外的连接条件`
  - 这个连接条件是与其它条件分开的
  - ON 子句使语句具有更高的易读性
  - 关键字 `JOIN、INNER JOIN、CROSS JOIN` 的含义是一样的，都表示`内连接`

##### 2. 内连接(INNER JOIN)的实现

- 语法

```sql
SELECT 字段列表 
FROM A表 
INNER JOIN B表 ON 关联条件 
WHERE 等其他子句;

SELECT e.employee_id, e.last_name, e.department_id, d.department_id, d.location_id 
FROM employees e 
JOIN departments d ON (e.department_id = d.department_id);

SELECT employee_id, city, department_name 
FROM employees e 
JOIN departments d ON d.department_id = e.department_id 
JOIN locations l ON d.location_id = l.location_id;
```

##### 3. 外连接(OUTER JOIN)的实现
###### 1. 左外连接(LEFT OUTER JOIN)

- 语法

```sql
#实现查询结果是A 
SELECT 字段列表 
FROM A表 
LEFT JOIN B表 ON 关联条件 
WHERE 等其他子句;

SELECT e.last_name, e.department_id, d.department_name 
FROM employees e 
LEFT OUTER JOIN departments d ON (e.department_id = d.department_id);
```

###### 2. 右外连接(RIGHT OUTER JOIN)

- 语法

```sql
#实现查询结果是B 
SELECT 字段列表 FROM A表 
RIGHT JOIN B表 ON 关联条件 
WHERE 等其他子句;

SELECT e.last_name, e.department_id, d.department_name 
FROM employees e 
RIGHT OUTER JOIN departments d ON (e.department_id = d.department_id);
```

##### 3. 满外连接(FULL OUTER JOIN)

- 满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。
- SQL99是支持满外连接的。使用`FULL JOIN` 或 `FULL OUTER JOIN`来实现。
- 需要注意的是，`MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION RIGHT join代替`

#### 4. UNION的使用

**合并查询结果**

利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并
时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔

- 语法格式

```sql
SELECT column,... 
FROM table1 
UNION [ALL] 
SELECT column,... 
FROM table2
```

`UNION操作符`

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.4f7zzuyifz80.jpg)

UNION 操作符返回两个查询的结果集的并集，去除重复记录

`UNION ALL操作符`

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.4g1qhvt0d7y0.jpg)

UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重

:::tip
注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据
不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效
率。
:::

举例：查询部门编号>90或邮箱包含a的员工信息

```sql
#方式1 
SELECT * FROM employees WHERE email LIKE '%a%' OR department_id>90

#方式2
SELECT * FROM employees WHERE email LIKE '%a%'
UNION 
SELECT * FROM employees WHERE department_id>90;
```

举例：查询中国用户中男性的信息以及美国用户中年男性的用户信息

```sql
SELECT id,cname FROM t_chinamale WHERE csex='男' 
UNION ALL 
SELECT id,tname FROM t_usmale WHERE tGender='male';
```

#### 5. 7种SQL JOINS的实现

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.1dc3ymx6c6bk.jpg)


```sql
#中图：内连接 A∩B 
SELECT employee_id,last_name,department_name 
FROM employees e 
JOIN departments d ON e.`department_id` = d.`department_id`;
```

```sql
#左上图：左外连接 
SELECT employee_id,last_name,department_name 
FROM employees e 
LEFT JOIN departments d ON e.`department_id` = d.`department_id`;
```

```sql
#右上图：右外连接 
SELECT employee_id,last_name,department_name 
FROM employees e 
RIGHT JOIN departments d ON e.`department_id` = d.`department_id`;
```

```sql
#左中图：A - A∩B 
SELECT employee_id,last_name,department_name 
FROM employees e 
LEFT JOIN departments d ON e.`department_id` = d.`department_id` 
WHERE d.`department_id` IS NULL
```

```sql
#右中图：B-A∩B 
SELECT employee_id,last_name,department_name 
FROM employees e 
RIGHT JOIN departments d ON e.`department_id` = d.`department_id` 
WHERE e.`department_id` IS NULL
```

```sql
#左下图：满外连接 
# 左中图 + 右上图 A∪B 
SELECT employee_id,last_name,department_name 
FROM employees e LEFT JOIN departments d ON e.`department_id` = d.`department_id` 
WHERE d.`department_id` IS NULL 
UNION ALL #没有去重操作，效率高 
SELECT employee_id,last_name,department_name 
FROM employees e 
RIGHT JOIN departments d ON e.`department_id` = d.`department_id`;
```

```sql
#右下图
#左中图 + 右中图 A ∪B- A∩B 或者 (A - A∩B) ∪ （B - A∩B） 
SELECT employee_id,last_name,department_name 
FROM employees e 
LEFT JOIN departments d ON e.`department_id` = d.`department_id` 
WHERE d.`department_id` IS NULL 
UNION ALL 
SELECT employee_id,last_name,department_name 
FROM employees e 
RIGHT JOIN departments d ON e.`department_id` = d.`department_id` 
WHERE e.`department_id` IS NULL
```

#### 6. SQL99语法新特性

##### 1. 自然连接

SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 `NATURAL JOIN` 用来表示自然连接。我们可以把
自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 所有相同的字段 ，然后进行 等值 连接

| SQL92                                                                                                                                                                                  | SQL99                                                                                             |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
| SELECT<br> employee_id,last_name,department_name <br>FROM employees e <br>JOIN departments d ON e.\`department_id\` = d.\`department_id\`<br> AND e.\`manager_id\` = d.\`manager_id\`; | SELECT employee_id,last_name,department_name <br>FROM employees e <br>NATURAL JOIN departments d; |


##### 2. USING连接

当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的 同名字段 进行等值连接。但是只能配
合JOIN一起使用。比如:

```sql
SELECT employee_id,last_name,department_name 
FROM employees e 
JOIN departments d USING (department_id);
```

你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING
的括号 () 中填入要指定的同名字段。同时使用 JOIN...USING 可以简化 JOIN ON 的等值连接。它与下
面的 SQL 查询结果是相同的：

```sql
SELECT employee_id,last_name,department_name 
FROM employees e ,departments d 
WHERE e.department_id = d.department_id;
```
#### 7. 注意事项

##### 1. 控制连接表数量

我们要 控制连接表的数量 。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下
降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制

:::tip
【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保
证被关联的字段需要有索引。
说明：即使双表 join 也要注意表索引、SQL 性能。
来源：阿里巴巴《Java开发手册》
:::


### 5. 子查询

子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入

SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者
需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集
合）进行比较

#### 1. 需求分析与问题解决

##### 1. 问题引出

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.590rjq0v42g0.jpg)

现有解决方式：

```sql
#方式一： 
SELECT salary FROM employees WHERE last_name = 'Abel';
SELECT last_name,salary FROM employees WHERE salary > 11000;

#方式二：自连接
SELECT e2.last_name,e2.salary 
FROM employees e1,employees e2 
WHERE e1.last_name = 'Abel' AND e1.`salary` < e2.`salary`

#方式三：子查询 
SELECT last_name,salary 
FROM employees 
WHERE salary > ( 
  SELECT salary FROM employees WHERE last_name = 'Abel' 
);
```

##### 2. 子查询的基本使用

- 子查询的基本语法结构：

```sql
SELECT select_list
FROM table
WHERE expr operator 
                (SELECT select_list
                 FROM   table);
```

- 子查询（内查询）在主查询之前一次执行完成
- 子查询的结果被主查询（外查询）使用
- **注意事项**
  - 子查询要包含在括号内
  - 将子查询放在比较条件的右侧
  - 单行操作符对应单行子查询，多行操作符对应多行子查询

##### 3. 子查询的分类

1. 我们按内查询的结果返回一条还是多条记录，将子查询分为 `单行子查询` 、 `多行子查询`

- `单行子查询`

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.58yi0phdv080.jpg)

- `多行子查询`

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.6x9mqv2kkuc0.jpg)

2. 我们按内查询是否被执行多次，将子查询划分为 `相关(或关联)子查询` 和 `不相关(或非关联)子查询`

子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条
件进行执行，那么这样的子查询叫做不相关子查询

如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询


#### 2. 单行子查询

##### 1. 单行比较操作符

| 操作符 | 含义                     |
| ------ | ------------------------ |
| =      | equal to                 |
| >      | greater than             |
| >=     | greater than or equal to |
| <      | less than                |
| <=     | less than or equal to    |
| <>     | not equal to             |

##### 2. 代码示例

**题目：查询工资大于149号员工工资的员工的信息**

```sql
SELECT last_name
FROM employees
WHERE salary > (SELECT salary FROM employees WHERE employee_id = 149);
```

**题目：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资**

```sql
SELECT last_name, job_id, salary 
FROM employees 
WHERE job_id = (SELECT job_id FROM employees WHERE employee_id = 141) 
AND salary > (SELECT salary FROM employees WHERE employee_id = 143);
```

**题目：返回公司工资最少的员工的last_name,job_id和salary**

```sql
SELECT last_name, job_id, salary 
FROM employees 
WHERE salary = (SELECT MIN(salary) FROM employees);
```

**题目：查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id， manager_id，department_id**

- 1：不成对比较

```sql
SELECT employee_id, manager_id, department_id 
FROM employees 
WHERE manager_id IN (SELECT manager_id FROM employees WHERE employee_id IN (174,141)) 
AND department_id IN (SELECT department_id FROM employees WHERE employee_id IN (174,141)) 
AND employee_id NOT IN(174,141);
```

- 2：成对比较

```sql
SELECT employee_id, manager_id, department_id 
FROM employees 
WHERE (manager_id, department_id) 
IN (SELECT manager_id, department_id 
    FROM employees 
    WHERE employee_id IN (141,174)) 
    AND employee_id NOT IN (141,174
    );
```

##### 3. HAVING 中的子查询

- 首先执行子查询
- 向主查询中的HAVING 子句返回结果

**题目：查询最低工资大于50号部门最低工资的部门id和其最低工资**

```sql
SELECT department_id, MIN(salary) 
FROM employees 
GROUP BY department_id 
HAVING MIN(salary) > (SELECT MIN(salary) FROM employees WHERE department_id = 50);
```

##### 4. CASE中的子查询

**题目：显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800 的department_id相同，则location为’Canada’，其余则为’USA’**

```sql
SELECT employee_id, last_name, 
      (CASE department_id 
            WHEN 
                (SELECT department_id FROM departments WHERE location_id = 1800) 
            THEN 'Canada' ELSE 'USA' END) 
      location FROM employees;
```

##### 5. 子查询中的空值问题

:::warning
子查询不返回任何行
:::

##### 6. 非法使用子查询

```sql
SELECT employee_id, last_name 
FROM employees 
WHERE salary = (SELECT MIN(salary) FROM employees GROUP BY department_id);
```

:::danger
Error Code: 1242

Subquery returns more then 1 row
:::

#### 3. 多行子查询

- 也称为集合比较子查询
- 内查询返回多行
- 使用多行比较操作符

##### 1. 多行比较操作符

| 操作符 | 含义                                                       |
| ------ | ---------------------------------------------------------- |
| IN     | 等于列表中的`任意一个`                                     |
| ANY    | 需要和单行比较操作符一起使用，和子查询返回的`某一个`值比较 |
| ALL    | 需要和单行比较操作符一起使用，和子查询返回的`所有`值比较   |
| SOME   | 实际上是ANY的别名，作用相同，一般常使用ANY                 |

##### 2. 代码示例

**题目：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary**

```sql
SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE salary < ANY 
                  (SELECT salary
                   FROM employees
                   WHERE job_id = 'IT_PROG')
AND job_id <> 'IT_PROG';
```

**题目：返回其它job_id中比job_id为‘IT_PROG’部门所有工资都低的员工的员工号、姓名、job_id以及salary**

```sql
SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE salary < ALL 
                  (SELECT salary
                   FROM employees
                   WHERE job_id = 'IT_PROG')
AND job_id <> 'IT_PROG';
```

**题目：查询平均工资最低的部门id**

```sql
#方式1： 
SELECT department_id 
FROM employees 
GROUP BY department_id 
HAVING AVG(salary) = ( SELECT MIN(avg_sal) FROM (SELECT AVG(salary) avg_sal FROM employees GROUP BY department_id ) dept_avg_sal )

#方式2： 
SELECT department_id 
FROM employees 
GROUP BY department_id 
HAVING AVG(salary) <= ALL ( SELECT AVG(salary) avg_sal FROM employees GROUP BY department_id )
```

##### 3. 空值问题

**不返回任何行**


#### 4. 相关子查询

##### 1. 相关子查询执行流程

如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件
关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 `关联子查询` 

相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询

![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.5ih21mufj9c0.jpg)

##### 2. 代码示例

**题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id**

```sql
# 1. 相关子查询
SELECT last_name, salary, department_id
FROM employees outer
WHERE salary > 
            (SELECT AVG(salary)
             FROM employees
             WHERE department_id = outer.department_id);

# 2. 在 FROM 中使用子查询
SELECT last_name,salary,e1.department_id 
FROM employees e1,(SELECT department_id,AVG(salary) dept_avg_sal FROM employees GROUP BY department_id) e2 
WHERE e1.`department_id` = e2.department_id 
AND e2.dept_avg_sal < e1.`salary`;
```

:::tip
`from` 型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别
名， 把它当成一张 `临时的虚拟的表` 来使用
:::

**题目：查询员工的id,salary,按照department_name 排序**

- 在ORDER BY 中使用子查询：

```sql
SELECT employee_id,salary 
FROM employees e 
ORDER BY ( SELECT department_name FROM departments d WHERE e.`department_id` = d.`department_id` );
```

**题目：若employees表中employee_id与job_history表中employee_id相同的数目不小于2，输出这些相同id的员工的employee_id,last_name和其job_id**

```sql
SELECT e.employee_id, last_name,e.job_id 
FROM employees e 
WHERE 2 <= (SELECT COUNT(*) FROM job_history WHERE employee_id = e.employee_id);
```

##### 3. EXISTS 与 NOT EXISTS关键字

- 关联子查询通常也会和 `EXISTS` 操作符一起来使用，用来检查在子查询中是否存在满足条件的行
- 如果在子查询中不存在满足条件的行
  - 条件返回 FALSE
  - 继续在子查询中查找
- 如果在子查询中存在满足条件的行
  - 不在子查询中继续查找
  - 条件返回 TRUE
- NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE

**题目：查询公司管理者的employee_id，last_name，job_id，department_id信息**

```sql
# 方式1
SELECT employee_id, last_name, job_id, department_id 
FROM employees e1 
WHERE EXISTS ( SELECT * FROM employees e2 WHERE e2.manager_id = e1.employee_id);

# 方式2：自连接
SELECT DISTINCT e1.employee_id, e1.last_name, e1.job_id, e1.department_id 
FROM employees e1 JOIN employees e2 
WHERE e1.employee_id = e2.manager_id;

# 方式3：
SELECT employee_id,last_name,job_id,department_id 
FROM employees 
WHERE employee_id IN ( SELECT DISTINCT manager_id FROM employees );
```

**题目：查询departments表中，不存在于employees表中的部门的department_id和department_name**

```sql
SELECT department_id, department_name 
FROM departments d 
WHERE NOT EXISTS (SELECT 'X' FROM employees WHERE department_id = d.department_id);
```
##### 4. 相关更新

使用相关子查询依据一个表中的数据更新另一个表的数据

```sql
UPDATE table1 alias1 
SET column = (SELECT expression FROM table2 alias2 WHERE alias1.column = alias2.column);
```

**题目：在employees中增加一个department_name字段，数据为员工对应的部门名称**

```sql
# 1
ALTER TABLE employees ADD(department_name VARCHAR2(14));

# 2 
UPDATE employees e 
SET department_name = (SELECT department_name FROM departments d WHERE e.department_id = d.department_id);
```

##### 5. 相关删除

```sql
DELETE FROM table1 alias1 
WHERE column operator (SELECT expression FROM table2 alias2 WHERE alias1.column = alias2.column);

DELETE FROM employees e 
WHERE employee_id in (SELECT employee_id FROM emp_history WHERE employee_id = e.employee_id);
```

##### 5. 子查询 VS 自连接

一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多

子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化


<!-- ### 1.8 显示表结构 DESC
```sql
DESCRIBE employees; 
-- 或
DESC employees;
```
![image](https://cdn.jsdelivr.net/gh/brook-w/image-hosting@master/mysql/image.ltyf0ntoej4.jpg)

各个字段的含义分别解释如下：
| 字段    | 描述                                                                                                                            |
| ------- | ------------------------------------------------------------------------------------------------------------------------------- |
| Field   | 表示字段名称                                                                                                                    |
| Type    | 表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的                                                            |
| Null    | 表示该列是否可以存储NULL值                                                                                                      |
| Key     | 表示该列是否已编制索引<br>PRI表示该列是表主键的一部分<br>UNI表示该列是UNIQUE索引的一部分<br>MUL表示在列中某个给定值允许出现多次 |
| Default | 表示该列是否有默认值，如果有，那么值是多少                                                                                      |
| Extra   | 表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等                                                                      | --> |