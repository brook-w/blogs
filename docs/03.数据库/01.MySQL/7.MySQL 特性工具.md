---
title: 7.MySQL 特性工具
date:  2022-03-07 00:00:00
permalink: /pages/ed33bc/
categories:
  - 数据库
  - MySQL
tags:
  - 
author: 
  name: brook-w
  link: https://github.com/brook-w
---


## 常见的数据库对象

|对象| 描述|
|---|---|
|表(TABLE) |表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录|
|数据字典| 就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看|
|约束(CONSTRAINT)|执行数据校验的规则，用于保证数据完整性的规则
|视图(VIEW) |一个或者多个数据表里的数据的逻辑显示，视图并不存储数据|
|索引(INDEX) |用于提高查询性能，相当于书的目录|
|存储过程(PROCEDURE)|用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境|
|存储函数(FUNCTION)|用于完成一次特定的计算，具有一个返回值|
|触发器|(TRIGGER)|相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理|



## 1. 视图

### 1. 视图概述

#### 1.  为什么使用视图？

视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。

#### 2. 视图的理解

- 视图是一种 `虚拟表` ，本身是 `不具有数据` 的，占用很少的内存空间，它是 SQL 中的一个重要概念
- `视图建立在已有表的基础上`, 视图赖以建立的这些表称为`基表`
![image](https://cdn.staticaly.com/gh/brook-w/image-hosting@master/mysql/image.47b1mekkjdg0.jpg)
- 视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然
- 向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为`存储起来的 SELECT 语句`
- 视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便

### 2. 创建视图
- 在 `CREATE VIEW` 语句中嵌入子查询
```sql
CREATE [OR REPLACE] 
[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] 
VIEW 视图名称 [(字段列表)] 
AS 查询语句 
[WITH [CASCADED|LOCAL] CHECK OPTION]

CREATE VIEW 视图名称 AS 查询语句

```
#### 1. 创建单表视图

```sql
CREATE VIEW empvu80 
AS 
SELECT employee_id, last_name, salary FROM employees WHERE department_id = 80;

-- 查询视图
SELECT * FROM salvu80;
```

![image](https://cdn.staticaly.com/gh/brook-w/image-hosting@master/mysql/image.kuwi3bqjc5c.jpg)

```sql
-- 示例1
CREATE VIEW emp_year_salary (ename,year_salary) 
AS 
SELECT ename,salary*12*(1+IFNULL(commission_pct,0)) FROM t_employee;

-- 示例2
CREATE VIEW salvu50 
AS
SELECT employee_id ID_NUMBER, last_name NAME,salary*12 ANN_SALARY FROM employees WHERE department_id = 50;
```

#### 2. 创建多表联合视图

```sql
-- 示例1
CREATE VIEW empview
AS
  SELECT employee_id emp_id,last_name NAME,department_name 
  FROM employees e,departments d 
  WHERE e.department_id = d.department_id;

-- 示例2
CREATE VIEW emp_dept 
AS
  SELECT ename,dname 
  FROM t_employee 
  LEFT JOIN t_department ON t_employee.did = t_department.did;

-- 示例3
CREATE VIEW dept_sum_vu (name, minsal, maxsal, avgsal) 
AS
  SELECT d.department_name, MIN(e.salary), MAX(e.salary),AVG(e.salary) 
  FROM employees e, departments d 
  WHERE e.department_id = d.department_id 
  GROUP BY d.department_name;
```

我们经常需要输出某个格式的内容，比如我们想输出员工姓名和对应的部门名，对应格式为
emp_name(department_name)，就可以使用视图来完成数据格式化的操作:

```sql
CREATE VIEW emp_depart 
AS
  SELECT CONCAT(last_name,'(',department_name,')') AS emp_dept 
  FROM employees e JOIN departments d 
  WHERE e.department_id = d.department_id
```

#### 3. 基于视图创建视图

当我们创建好一张视图之后，还可以在它的基础上继续创建视图

举例：联合“emp_dept”视图和“emp_year_salary”视图查询员工姓名、部门名称、年薪信息创建 “emp_dept_ysalary”视图。

```sql
CREATE VIEW emp_dept_ysalary 
AS
  SELECT emp_dept.ename,dname,year_salary 
  FROM emp_dept 
  INNER JOIN emp_year_salary ON emp_dept.ename = emp_year_salary.ename
```

### 3. 查看视图

```sql
-- 语法1：查看视图数据，表数据
SHOW TABLES;

-- 语法2：查看视图结构
DESC / DESCRIBE 视图名称;

-- 语法3：查看视图的属性信息
SHOW TABLE STATUS LIKE '视图名称'; --执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表

-- 语法4：查看视图的详细定义信息
SHOW CREATE VIEW 视图名称;
```

### 4. 更新视图的数据(`不推荐直接更新视图数据`)

#### 1. 一般情况

MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的
数据发生变化时，数据表中的数据也会发生变化，反之亦然

举例：UPDATE操作

```sql
SELECT ename,tel FROM emp_tel WHERE ename = '孙洪亮';
+---------+-------------+
| ename   | tel         | 
+---------+-------------+
| 孙洪亮  | 13789098765  | 
+---------+-------------+

UPDATE emp_tel SET tel = '13789091234' WHERE ename = '孙洪亮';

SELECT ename,tel FROM emp_tel WHERE ename = '孙洪亮';
+---------+-------------+
| ename | tel | 
+---------+-------------+
| 孙洪亮 | 13789091234 | 
+---------+-------------+

SELECT ename,tel FROM t_employee WHERE ename = '孙洪亮';
+---------+-------------+
| ename   | tel         | 
+---------+-------------+
| 孙洪亮   | 13789091234 | 
+---------+-------------+
```

#### 2. 不可更新的视图

要使视图可更新，视图中的行和底层基本表中的行之间必须存在 `一对一` 的关系。另外当视图定义出现如
下情况时，视图不支持更新操作:
- 在定义视图的时候指定了 `ALGORITHM = TEMPTABLE`，视图将不支持INSERT和DELETE操作
- 视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作
- 在定义视图的SELECT语句中使用了 `JOIN联合查询` ，视图将不支持INSERT和DELETE操作
- 在定义视图的SELECT语句后的字段列表中使用了 `数学表达式` 或 `子查询` ，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值
- 在定义视图的SELECT语句后的字段列表中使用 `DISTINCT` 、 `聚合函数` 、 `GROUP BY` 、 `HAVING` 、 `UNION` 等，视图将不支持INSERT、UPDATE、DELETE；
- 在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持 INSERT、UPDATE、DELETE；
- 视图定义基于一个 `不可更新视图`
- 常量视图

:::tip
虽然可以更新视图数据，但总的来说，视图作为 `虚拟表` ，主要用于 `方便查询` ，不建议更新视图的
数据。对视图数据的更改，都是通过对实际数据表里数据的操作来完成的
:::

### 5. 修改、删除视图

#### 1. 修改视图

```sql
-- 方式1：使用`CREATE OR REPLACE VIEW` 子句`修改视图`
CREATE OR REPLACE VIEW empvu80 (id_number, name, sal, department_id) 
AS
  SELECT employee_id, first_name || ' ' || last_name, salary, department_id 
  FROM employees 
  WHERE department_id = 80;

-- 方式2：ALTER VIEW
ALTER VIEW 视图名称 AS查询语句
```
#### 2. 删除视图

- 删除视图只是删除视图的定义，并不会删除基表的数据
- 删除视图的语法是:

```sql
DROP VIEW IF EXISTS 视图名称;
DROP VIEW IF EXISTS 视图名称1,视图名称2,视图名称3,...;
```

:::warning
说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这
样的视图c需要手动删除或修改，否则影响使用
:::

### 6. 总结

#### 1. 视图优点

- 操作简单
- 减少数据冗余
- 数据安全
  - MySQL将用户对数据的 `访问限制` 在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有 `隔离性` 。视图相当于在用户和实际的数据表之间加了一层虚拟表
  ![image](https://cdn.staticaly.com/gh/brook-w/image-hosting@master/mysql/image.7ku3gmmou0o0.jpg)
  - 同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，`用户不需要查询数据表，可以直接通过视图获取数据表中的信息`。这在一定程度上保障了数据表中数据的安全性
- 适应灵活多变的需求
- 分解复杂的查询逻辑

#### 2. 不足之处

- 当`基表`发生变化的时候，需要及时对相关的视图进行维护
- 出现嵌套视图会维护复杂，`可读性变差`
- 实际项目中，如果视图过多，会导致数据库维护成本的问题

## 2.约束

### 1. 约束(constraint)概述

#### 1. 为什么需要约束

`数据完整性`（Data Integrity）是指数据的`精确性`（Accuracy）和`可靠性`（Reliability）。它是防止数据库中
存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的

为了保证数据的完整性，SQL规范以约束的方式对`表数据进行额外的条件限制`。从以下四个方面考虑:
- `实体完整性（Entity Integrity）` ：例如，同一个表中，不能存在两条完全相同无法区分的记录
- `域完整性（Domain Integrity）` ：例如：年龄范围0-120，性别范围“男/女”
- `引用完整性（Referential Integrity）` ：例如：员工所在部门，在部门表中要能找到这个部门
- `用户自定义完整性（User-defined Integrity）` ：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍

#### 2. 什么是约束

**约束是表级的强制规定**

可以在**创建表时规定约束（通过 CREATE TABLE 语句）**，或者在**表创建之后通过 ALTER TABLE 语句规定约束**

#### 3. 约束的分类

- 根据约束数据列的限制，约束可分为：
  - 单列约束：每个约束只约束一列
  - 多列约束：每个约束可约束多列数据
- 根据约束的作用范围，约束可分为：
  - 列级约束：只能作用在一个列上，跟在列的定义后面
  - 表级约束：可以作用在多个列上，不与列一起，而是单独定义

|位置 |支持的约束类型| 是否可以起约束名|
|---|---|---|
| 列级约束： 列的后面| 语法都支持，但外键没有效果 |不可以|
| 表级约束： 所有列的下面 |默认和非空不支持，其他支持 |可以（主键没有效果）|

- 根据约束起的作用，约束可分为：
  - NOT NULL 非空约束，规定某个字段不能为空
  - UNIQUE 唯一约束，规定某个字段在整个表中是唯一的
  - PRIMARY KEY 主键(非空且唯一)约束
  - FOREIGN KEY 外键约束
  - CHECK 检查约束
  - DEFAULT 默认值约束

:::tip
MySQL不支持check约束，但可以使用check约束，而没有任何效果
:::

查看某个表已有的约束

```sql
#information_schema数据库名（系统库） 
#table_constraints表名称（专门存储各个表的约束） 
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';
```

### 2. 非空约束

#### 1. 特点

- 默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型
- 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空
- 一个表可以有很多列都分别限定了非空
- 空字符串''不等于NULL，0也不等于NULL

#### 2. 添加非空约束

1. 建表时：

```sql
CREATE TABLE 表名称( 
  字段名 数据类型, 
  字段名 数据类型 NOT NULL, 
  字段名 数据类型 NOT NULL 
);

-- 示例
CREATE TABLE emp( 
  id INT(10) NOT NULL, 
  NAME VARCHAR(20) NOT NULL, 
  sex CHAR NULL 
);

CREATE TABLE student( 
  sid int, 
  sname varchar(20) not null, 
  tel char(11) , 
  cardid char(18) not null 
);

-- 插入数据
insert into student values(1,'张三','13710011002','110222198912032545'); #成功 

insert into student values(2,'李四','13710011002',null);#身份证号为空 
ERROR 1048 (23000): Column 'cardid' cannot be null 

insert into student values(2,'李四',null,'110222198912032546');#成功，tel允许为空 

insert into student values(3,null,null,'110222198912032547');#失败 
ERROR 1048 (23000): Column 'sname' cannot be null
```

2. 建表后：

```sql
alter table 表名称 modify 字段名 数据类型 not null;

-- 示例
ALTER TABLE emp MODIFY sex VARCHAR(30) NOT NULL; 
ALTER TABLE student modify sname varchar(20) NOT NULL;
```

#### 3. 删除非空约束

```sql
#去掉not null，相当于修改某个非注解字段，该字段允 许为空 
alter table 表名称 modify 字段名 数据类型 NULL;
# 或
#去掉not null，相当于修改某个非注解字段，该字段允许为空
alter table 表名称 modify 字段名 数据类型;

-- 示例
ALTER TABLE emp MODIFY sex VARCHAR(30) NULL; 
ALTER TABLE emp MODIFY NAME VARCHAR(15) DEFAULT 'abc' NULL;
```

### 3. 唯一性约束

#### 1. 特点

- 同一个表可以有多个唯一约束。
- 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。
- 唯一性约束允许列值为空。
- 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。
- MySQL会给唯一约束的列上默认创建一个唯一索引。

#### 2. 添加唯一约束

1. 建表时
```sql
create table 表名称( 
  字段名 数据类型, 
  字段名 数据类型 unique, 
  字段名 数据类型 unique key, 
  字段名 数据类型 
);

create table 表名称( 
  字段名 数据类型, 
  字段名 数据类型, 
  字段名 数据类型, 
  [constraint 约束名] unique key(字段名) 
);

-- 示例
create table student( 
  sid int, sname varchar(20), 
  tel char(11) unique, 
  cardid char(18) unique key 
);

CREATE TABLE t_course( 
  cid INT UNIQUE, 
  cname VARCHAR(100) UNIQUE, 
  description VARCHAR(200) 
);

CREATE TABLE USER( 
  id INT NOT NULL, 
  NAME VARCHAR(25), 
  PASSWORD VARCHAR(16),
  -- 使用表级约束语法 
  CONSTRAINT uk_name_pwd 
  UNIQUE(NAME,PASSWORD) -- 表示用户名和密码组合不能重复
);
```

2. 建表后

```sql
#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯 一的
#方式1：
alter table 表名称 add unique key(字段列表);

#方式2： 
alter table 表名称 modify 字段名 字段类型 unique;

-- 举例1
ALTER TABLE USER ADD UNIQUE(NAME,PASSWORD);
ALTER TABLE USER ADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD);
ALTER TABLE USER MODIFY NAME VARCHAR(20) UNIQUE;

-- 举例2
create table student( sid int primary key, sname varchar(20), tel char(11) , cardid char(18) );
alter table student add unique key(tel); 
alter table student add unique key(cardid);
```

#### 3. 关于复合唯一约束
 
```sql
create table 表名称( 
  字段名 数据类型, 
  字段名 数据类型, 
  字段名 数据类型, 
  unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多 个字段的组合是唯一的 
);

#学生表 
create table student( 
  sid int, #学号 
  sname varchar(20), #姓名 
  tel char(11) unique key, #电话 
  cardid char(18) unique key #身份证号 
);

#课程表 
create table course( 
  cid int, #课程编号 
  cname varchar(20) #课程名称 
);

#选课表 
create table student_course( 
  id int, sid int, 
  cid int, score int, 
  unique key(sid,cid) #复合唯一 
);

insert into student values(1,'张三','13710011002','101223199012015623');#成功 
insert into student values(2,'李四','13710011003','101223199012015624');#成功 
insert into course values(1001,'Java'),(1002,'MySQL');#成功

select * from student;
+-----+-------+-------------+--------------------+
| sid | sname | tel         | cardid             | 
+-----+-------+-------------+--------------------+
| 1   | 张三  | 13710011002 | 101223199012015623 |
| 2   | 李四  | 13710011003 | 101223199012015624 | 
+-----+-------+-------------+--------------------+

select * from course;
+------+-------+
| cid | cname  | 
+------+-------+
| 1001 | Java  | 
| 1002 | MySQL | 
+------+-------+

insert into student_course values 
  (1, 1, 1001, 89), 
  (2, 1, 1002, 90), 
  (3, 2, 1001, 88), 
  (4, 2, 1002, 56); #成功

select * from student_course;
+----+------+------+-------+
| id | sid | cid | score | 
+----+------+------+-------+
| 1  | 1   | 1001| 89      | 
| 2  | 1   | 1002| 90      | 
| 3  | 2   | 1001| 88      | 
| 4  | 2   | 1002| 56      | 
+----+------+------+-------+

insert into student_course values (5, 1, 1001, 88);#失败
ERROR 1062 (23000): Duplicate entry '1-1001' for key 'sid' 违反sid-cid的复合唯一
```

#### 4. 删除唯一约束

- 添加唯一性约束的列上也会自动创建唯一索引。
- 删除唯一约束只能通过删除唯一索引的方式删除。
- 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。
- 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。

```sql
# 可以通过 show index from 表名称; 查看表的索引

SELECT * FROM information_schema.table_constraints WHERE table_name = '表名'; #查看都有哪 些约束 

ALTER TABLE USER DROP INDEX uk_name_pwd; 
```










### 4. PRIMARY KEY 约束

#### 1. 特点

- 主键约束相当于`唯一约束+非空约束`的组合，主键约束列不允许重复，也不允许出现空值
- 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建
- 主键约束对应着表中的一列或者多列（复合主键）
- 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复
- `MySQL的主键名总是PRIMARY`，就算自己命名了主键约束名也没用
- 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了
- 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。

#### 2. 添加主键约束

1. 建表时
```sql
create table 表名称( 
  字段名 数据类型 primary key, #列级模式 
  字段名 数据类型, 
  字段名 数据类型 
);

create table 表名称( 
  字段名 数据类型, 
  字段名 数据类型, 
  字段名 数据类型, 
  [constraint 约束名] primary key(字段名) #表级模式 
);

-- 示例1
create table temp( id int primary key, name varchar(20) );
desc temp;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra | 
+-------+-------------+------+-----+---------+-------+
| id    | int(11)     | NO   | PRI | NULL    |       | 
| name  | varchar(20) | YES  |     | NULL    |       | 
+-------+-------------+------+-----+---------+-------+

-- 示例2 一个表建立两个主键约束
create table temp( 
  id int primary key, 
  name varchar(20) primary key 
);
ERROR 1068 (42000): Multiple（多重的） primary key defined（定义）
```

- 列级约束

```sql
CREATE TABLE emp4( 
  id INT PRIMARY KEY AUTO_INCREMENT , 
  NAME VARCHAR(20) 
);
```

- 表级约束

```sql
CREATE TABLE emp5(
  id INT NOT NULL AUTO_INCREMENT, 
  NAME VARCHAR(20), 
  pwd VARCHAR(15), 
  CONSTRAINT emp5_id_pk PRIMARY KEY(id) 
);
```

2. 建表后：

```sql
ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多 个字段的话，是复合主键

ALTER TABLE student ADD PRIMARY KEY (sid); 
ALTER TABLE emp5 ADD PRIMARY KEY(NAME,pwd);
```

#### 3. 关于复合主键


```sql
create table 表名称( 
  字段名 数据类型, 
  字段名 数据类型, 
  字段名 数据类型, 
  primary key(字段名1,字段名2) #表示字段1和字段2的组合是唯一的，也可以有更多个字段 
);

#学生表 
create table student( 
  sid int primary key, #学号 
  sname varchar(20) #学生姓名 
);
#课程表 
create table course( 
  cid int primary key, #课程编号 
  cname varchar(20) #课程名称 
);
#选课表 
create table student_course( 
  sid int, 
  cid int, score int, 
  primary key(sid,cid) #复合主键 
);

insert into student values(1,'张三'),(2,'李四'); 
insert into course values(1001,'Java'),(1002,'MySQL');
```

#### 4. 删除主键约束

```sql
alter table 表名称 drop primary key;
ALTER TABLE student DROP PRIMARY KEY; 
ALTER TABLE emp5 DROP PRIMARY KEY;
```
:::tip 说明
删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在
:::


### 5. 自增列：AUTO_INCREMENT

#### 1. 特点和要求

- 一个表最多只能有一个自增长列
- 当需要产生唯一标识符或顺序值时，可设置自增长
- 自增长列约束的列必须是键列（主键列，唯一键列）
- 自增约束的列的数据类型必须是整数类型
- 如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值

#### 2. 添加自增约束

1. 建表时

```sql
create table 表名称( 
  字段名 数据类型 primary key auto_increment, 
  字段名 数据类型 unique key not null, 
  字段名 数据类型 unique key, 
  字段名 数据类型 not null default 默认值, 
);

create table 表名称( 
  字段名 数据类型 default 默认值 , 
  字段名 数据类型 unique key auto_increment, 
  字段名 数据类型 not null default 默认值,
  primary key(字段名) 
);

-- 示例
create table employee( eid int primary key auto_increment, ename varchar(20) );
desc employee; 
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          | 
+-------+-------------+------+-----+---------+----------------+
| eid   | int(11)     | NO   | PRI | NULL    | auto_increment | 
| ename | varchar(20) | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
```

2. 建表后

```sql
alter table 表名称 modify 字段名 数据类型 auto_increment;

-- 示例
create table employee( 
  eid int primary key , 
  ename varchar(20) 
);
alter table employee modify eid int auto_increment;
```

#### 3. 如何删除自增约束

```sql
#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束 
alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除 
alter table employee modify eid int;

desc employee; 
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra | 
+-------+-------------+------+-----+---------+-------+
| eid   | int(11)     | NO   | PRI | NULL    |       | 
| ename | varchar(20) | YES  |     | NULL    |       | 
+-------+-------------+------+-----+---------+-------+
```

#### 4. MySQL 8.0新特性—自增变量的持久化

在MySQL 8.0之前，自增主键 `AUTO_INCREMENT` 的值如果大于`max(primary key)+1`，在MySQL重启后，会重
置`AUTO_INCREMENT=max(primary key)+1`，这种现象在某些情况下会导致业务主键冲突或者其他难以发
现的问题。 

MySQL 8.0将自增主键的计数器持久化到 `重做日志` 中。每次计数器发生改变，都会将其写入重做日志
中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值

### 6. FOREIGN KEY 约束 (开发中不建议使用)

#### 1. 作用

限定某个表的某个字段的引用完整性。

比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分


#### 2. 主表和从表/父表和子表

- 主表（父表）：被引用的表，被参考的表
- 从表（子表）：引用别人的表，参考别人的表

例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。

例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是
主表，选课表是从表。

#### 3. 特点

- 从表的外键列，必须引用/参考主表的主键或唯一约束的列
  - 为什么？因为被依赖/被参考的值必须是唯一的
- 在创建外键约束时，如果不给外键约束命名，`默认名不是列名，而是自动产生一个外键名`（例如student_ibfk_1;），也可以指定外键约束名。
- 创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表
- 删表时，先删从表（或先删除外键约束），再删除主表
- 当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖
该记录的数据，然后才可以删除主表的数据
- 在“从表”中指定外键约束，并且一个表可以建立多个外键约束
- 从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can't create table'database.tablename'(errno: 150)”。
- `当创建外键约束时，系统默认会在所在的列上建立对应的普通索引`。但是索引名是外键的约束
名。（根据外键查询效率很高）
- 删除外键约束后，必须 手动 删除对应的索引

#### 4. 添加外键约束

1. 建表时

```sql
create table 主表名称( 
  字段1 数据类型 primary key, 
  字段2 数据类型 
);
create table 从表名称( 
  字段1 数据类型 primary key, 
  字段2 数据类型, 
  [CONSTRAINT <外键约束名称>] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段) 
);

#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样 
#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样

-- FOREIGN KEY: 在表级指定子表中的列
-- REFERENCES: 标示在父表中的列 

create table dept( 
  #主表 did int primary key, 
  #部门编号 dname varchar(50) #部门名称 
);
create table emp(#从表 
  eid int primary key, #员工编号 
  ename varchar(5), #员工姓名 
  deptid int, #员工所在的部门
  foreign key (deptid) references dept(did) #在从表中指定外键约束 
  #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号 
);


-- 说明： 
--  （1）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。 
--  （2）删除表时，先删除从表emp，再删除主表dept
``` 

2. 建表后

一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不
过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那
么，就要用修改表的方式来补充定义

```sql
-- 格式
ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用 字段) [on update xx][on delete xx];

-- 举例1
ALTER TABLE emp1 ADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id);

-- 举例2
create table dept( 
  did int primary key, #部门编号
  dname varchar(50) #部门名称 
);
create table emp( 
  eid int primary key, #员工编号 
  ename varchar(5), #员工姓名 
  deptid int #员工所在的部门 
);
#这两个表创建时，没有指定外键的话，那么创建顺序是随意

alter table emp add foreign key (deptid) references dept(did);
```

#### 5. 总结（约束双方）

- 添加了外键约束后，主表的修改和删除数据受约束
- 添加了外键约束后，从表的添加和修改数据受约束
- 在从表上建立外键，要求主表必须存在
- 删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除

#### 6. 约束等级

- `Cascade`方式 ：在父表上update/delete记录时，同步update/delete掉子表的匹配记录
- `Set null`方式 ：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null No action方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作
- `Restrict`方式 ：同no action， 都是立即检查外键约束
- `Set default`方式 （在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别

**如果没有指定等级，就相当于Restrict方式**

对于外键约束，最好是采用: **`ON UPDATE CASCADE ON DELETE RESTRICT`** 的方式

```sql
create table dept( 
  did int primary key, #部门编号 
  dname varchar(50) #部门名称 
);
create table emp( 
  eid int primary key, #员工编号 
  ename varchar(5), #员工姓名 
  deptid int, #员工所在的部门
  foreign key (deptid) references dept(did) on update cascade on delete cascade 
  #把修改操作设置为级联修改等级，把删除操作也设置为级联删除等级 );
```

#### 7. 删除外键约束

```sql
-- (1)第一步先查看约束名和删除外键约束 
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';#查看某个表的约束名 ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;

--（2）第二步查看索引名和删除索引。（注意，只能手动删除） 
SHOW INDEX FROM 表名称; #查看某个表的索引名 
ALTER TABLE 从表名 DROP INDEX 索引名;

-- 示例1
-- 1)
SELECT * FROM information_schema.table_constraints WHERE table_name = 'emp'; 
alter table emp drop foreign key emp_ibfk_1; 

-- 2)
show index from emp;
alter table emp drop index deptid;
```

#### 8. 开发场景

- 问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否
一定要建外键约束？
> 不一定

- 问题2：建和不建外键约束有什么区别？
> 建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制
> 
> 不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的 `引用完整` 性 ，只能依 `靠程序员的自觉` ，或者是 `在程序中进行限定`，人为控制

:::tip
在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适
合。比如大型网站的中央数据库，可能会 `因为外键约束的系统开销而变得非常慢` 。所以， MySQL 允
许你不使用系统自带的外键约束，在 `应用层面` 完成检查数据一致性的逻辑。也就是说，即使你不
用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。
:::

:::tip 阿里开发规范之MySQL外键约束
- 【 强制 】不得使用外键与级联，一切外键概念必须在应用层解决。
  - 说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学
生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。`外键与级联更新适用于单机低并发` ，不适合 `分布式` 、 `高并发集群` ；级联更新是强阻塞，存在数据库 `更新风暴` 的风险；外键影响数据库的 `插入速度`
:::

### 7. CHECK 约束

**MySQL 8.0可用**

```sql
create table employee( 
  eid int primary key, 
  ename varchar(5), 
  gender char check ('男' or '女') 
);
```
### 8. DEFAULT约束

#### 1. 如何给字段加默认值

```sql
create table 表名称( 
  字段名 数据类型 primary key, 
  字段名 数据类型 unique key not null, 
  字段名 数据类型 unique key, 
  字段名 数据类型 not null default 默认值, 
);
create table 表名称(
  字段名 数据类型 default 默认值 , 
  字段名 数据类型 not null default 默认值, 
  字段名 数据类型 not null default 默认值, 
  primary key(字段名), unique key(字段名) 
);
-- 说明：默认值约束一般不在唯一键和主键列上加 

create table employee( eid int primary key, ename varchar(20) not null, gender char default '男', tel char(11) not null default '' #默认是空字符串 );
```

#### 2. 修改默认约束

```sql
alter table 表名称 modify 字段名 数据类型 default 默认值;
#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被 除了 
#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默 认值约束，否则就删除了

alter table 表名称 modify 字段名 数据类型 default 默认值 not null;

alter table employee modify tel char(11) default '' not null;#给tel字段增加默认值约束，并 保留非空约束
```

#### 3. 如何删除默认值约束

```sql
alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束 
alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束 
alter table employee modify gender char; #删除gender字段默认值约束，如果有非空约束，也一并删除 
alter table employee modify tel char(11) not null;#删除tel字段默认值约束，保留非空约束
```

### 9. 注意事项

- 为什么建表时，加 not null default '' 或 default 0 ？
> 不想让表中出现null值

- 为什么不想要 null 的值 ？
> - 不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null
>
> - 效率不高。影响提高索引效果。因此，我们往往在建表时 not null default '' 或 default 0

- 带AUTO_INCREMENT约束的字段值是从1开始的吗？
> 在MySQL中，默认`AUTO_INCREMENT`的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性

- 并不是每个表都可以任意选择存储引擎？
> 外键约束（FOREIGN KEY）不能跨引擎使用
>
> MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的

## 3. 触发器(不推荐使用)

### 1. 触发器概述

MySQL从 5.0.2 版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序

触发器是由 `事件来触发` 某个操作，这些事件包括 `INSERT` 、 `UPDATE` 、 `DELETE` 事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会 自动 激发触发器执行相应的操作

### 2. 触发器的创建

```sql
-- 语法
CREATE TRIGGER 触发器名称
{BEFORE|AFTER} {INSERT|UPDATE|DELETE} ON 表名 
FOR EACH ROW 
触发器执行的语句块
```

说明：
- `表名` ：表示触发器监控的对象
- `BEFORE|AFTER` ：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发
- `INSERT|UPDATE|DELETE` ：表示触发的事件
  - INSERT 表示插入记录时触发
  - UPDATE 表示更新记录时触发
  - DELETE 表示删除记录时触发
- `触发器执行的语句块` ：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块

```sql

-- 举例1
-- 1) 创建数据表：
CREATE TABLE test_trigger ( 
  id INT PRIMARY KEY AUTO_INCREMENT, 
  t_note VARCHAR(30) 
);
CREATE TABLE test_trigger_log ( 
  id INT PRIMARY KEY AUTO_INCREMENT, 
  t_log VARCHAR(30) 
);

-- 2) 创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息
DELIMITER //
CREATE TRIGGER before_insert 
BEFORE INSERT ON test_trigger 
FOR EACH ROW 
BEGIN
  INSERT INTO test_trigger_log (t_log) 
  VALUES('before_insert');
END //
DELIMITER ;

-- 3) 向test_trigger数据表中插入数据
INSERT INTO test_trigger (t_note) VALUES ('测试 BEFORE INSERT 触发器');

-- 4) 查看test_trigger_log数据表中的数据
SELECT * FROM test_trigger_log; 
+----+---------------+
| id | t_log         | 
+----+---------------+
| 1  | before_insert | 
+----+---------------+
```

```sql
-- 举例2： 1、创建名称为after_insert的触发器，向test_trigger数据表插入数据之后，向test_trigger_log数据表中插入after_insert的日志信息。
DELIMITER // 
CREATE TRIGGER after_insert 
AFTER INSERT ON test_trigger 
FOR EACH ROW 
BEGIN 
  INSERT INTO test_trigger_log (t_log) 
  VALUES('after_insert'); 
END // 
DELIMITER ;

-- 2) 向test_trigger数据表中插入数据。
INSERT INTO test_trigger (t_note) VALUES ('测试 AFTER INSERT 触发器');

-- 3) 查看test_trigger_log数据表中的数据
SELECT * FROM test_trigger_log; 
+----+---------------+
| id | t_log         |
+----+---------------+
| 1  | before_insert | 
| 2  | before_insert | 
| 3  | after_insert  |
+----+---------------+
```

```sql
-- 举例3：定义触发器“salary_check_trigger”，基于员工表“employees”的INSERT事件，在INSERT之前检查将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value为'HY000'的错误，从而使得添加失败。上面触发器声明过程中的NEW关键字代表INSERT添加语句的新记录。
DELIMITER //

CREATE TRIGGER salary_check_trigger 
BEFORE INSERT ON employees 
FOR EACH ROW 
BEGIN 
  DECLARE mgrsalary DOUBLE;
  SELECT salary INTO mgrsalary FROM employees WHERE employee_id = NEW.manager_id; 
  IF NEW.salary > mgrsalary THEN 
    SIGNAL SQLSTATE 'HY000' SET MESSAGE_TEXT = '薪资高于领导薪资错误'; 
  END IF; 
END //
DELIMITER ;
```

### 3. 查看、删除触发器

#### 1. 查看触发器

```sql
--1) 查看当前数据库的所有触发器的定义
SHOW TRIGGERS;

--2) 查看当前数据库中某个触发器的定义
SHOW CREATE TRIGGER 触发器名

--3) 从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息
SELECT * FROM information_schema.TRIGGERS;
```

#### 2. 删除触发器

```sql
DROP TRIGGER IF EXISTS 触发器名称;
```

### 4. 触发器的优缺点

#### 1. 优点

1. 触发器可以确保数据的完整性
2. 触发器可以帮助我们记录操作日志
3. 触发器还可以用在操作数据前，对数据进行合法性检查

#### 2. 缺点

1. 触发器可读性差
2. 相关数据的变更，可能会导致触发器出错

## 4. 存储过程

### 1. 存储过程概述

#### 1. 理解


**含义**：存储过程的英文是 Stored Procedure 。它的思想很简单，就是一组经过 预先编译 的 SQL 语句
的封装。

执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用
存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。

**好处**： 
- 1、简化操作，提高了sql语句的重用性，减少了开发程序员的压力 
- 2、减少操作过程中的失误，提高效率
- 3、减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） 4、减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性

**和视图、函数的对比**：

它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是 `虚拟表` ，
通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以 `直接操作底层数据表` ，相比于面向集
合的操作方式，能够实现一些更复杂的数据处理。

一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于
函数，存储过程是 `没有返回值` 的

#### 2. 分类

存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下:

- 1、没有参数（无参数无返回） 
- 2、仅仅带 IN 类型（有参数无返回） 
- 3、仅仅带 OUT 类型（无参数有返回） 
- 4、既带 IN 又带 OUT（有参数有返回） 
- 5、带 INOUT（有参数有返回）

### 2. 创建存储过程

#### 1. 语法分析

```sql
CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...) 
[characteristics ...] 
BEGIN
  存储过程体 
END
```

- 1、参数前面的符号的意思
  - IN ：当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类， 默认就是 IN ，表示输入参数。
  - OUT ：当前参数为输出参数，也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。
  - INOUT ：当前参数既可以为输入参数，也可以为输出参数。
- 2、形参类型可以是 MySQL数据库中的任意类型
- 3、`characteristics` 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：
```sql
LANGUAGE SQL 
| [NOT] DETERMINISTIC 
| { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } 
| SQL SECURITY { DEFINER | INVOKER } 
| COMMENT 'string
```
  - `LANGUAGE SQL` ：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL
  - `[NOT] DETERMINISTIC` ：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。
  - `{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }`:指明子程序使用SQL语句的限制:
    - CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句
    - NO SQL表示当前存储过程的子程序中不包含任何SQL语句
    - READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句
    - MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句
    - 默认情况下，系统会指定为CONTAINS SQL
  - `SQL SECURITY { DEFINER | INVOKER }` ：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程
     - `DEFINER` 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程
     - `INVOKER` 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程
     - 如果没有设置相关的值，则MySQL默认指定值为DEFINER
  - `COMMENT 'string'` ：注释信息，可以用来描述存储过程
- 4、 存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END
- 5、需要设置新的结束标记
```sql
DELIMITER 新的结束标记
```
#### 2. 代码举例

```sql
-- 举例1：创建存储过程select_all_data()，查看 emps 表的所有数据
DELIMITER $ 
CREATE PROCEDURE select_all_data() 
BEGIN
  SELECT * FROM emps; 
END $ 
DELIMITER;

-- 举例2：创建存储过程avg_employee_salary()，返回所有员工的平均工资
DELIMITER // 
CREATE PROCEDURE avg_employee_salary () 
BEGIN
  SELECT AVG(salary) AS avg_salary FROM emps; 
END // 
DELIMITER ;

-- 举例3：创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值
CREATE PROCEDURE show_max_salary() 
  LANGUAGE SQL 
  NOT DETERMINISTIC 
  CONTAINS SQL 
  SQL SECURITY DEFINER 
  COMMENT '查看最高薪资' 
  BEGIN
    SELECT MAX(salary) FROM emps; 
  END // 
DELIMITER;
```

#### 3. 调用存储过程

##### 1. 调用格式

```sql
CALL 存储过程名(实参列表)

-- 1、调用in模式的参数：
CALL sp1('值');

-- 2、调用out模式的参数：
SET @name; CALL sp1(@name); SELECT @name;

-- 3、调用inout模式的参数：
SET @name=值; CALL sp1(@name); SELECT @name;
```

##### 2.  代码举例

```sql
DELIMITER // 
CREATE PROCEDURE CountProc(IN sid INT,OUT num INT) 
BEGIN
  SELECT COUNT(*) INTO num FROM fruits WHERE s_id = sid; 
END // 
DELIMITER;

-- 调用过程
CALL CountProc (101, @num);

-- 查看返回结果
SELECT @num;
```

### 3. 存储过程和函数的查看、修改、删除

#### 1. 查看
```sql
-- 1. 使用SHOW CREATE语句查看存储过程和函数的创建信息
SHOW CREATE {PROCEDURE | FUNCTION} 存储过程名或函数名
SHOW CREATE FUNCTION test_db.CountProc;

-- 2. 使用SHOW STATUS语句查看存储过程和函数的状态信息
SHOW {PROCEDURE | FUNCTION} STATUS [LIKE 'pattern']
SHOW PROCEDURE STATUS LIKE 'SELECT%'

-- 3. 从information_schema.Routines表中查看存储过程和函数的信息
SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME='存储过程或函数的名' [AND ROUTINE_TYPE = {'PROCEDURE|FUNCTION'}];
```

#### 2. 修改
```sql
ALTER {PROCEDURE | FUNCTION} 存储过程或函数的名 [characteristic ...]

--示例1
ALTER PROCEDURE CountProc MODIFIES SQL DATA SQL SECURITY INVOKER ;

-- 示例2
ALTER FUNCTION CountProc READS SQL DATA COMMENT 'FIND NAME' ;
```

#### 3. 删除

```sql
DROP {PROCEDURE | FUNCTION} [IF EXISTS] 存储过程或函数的名

--示例
DROP PROCEDURE CountProc;
DROP FUNCTION CountProc;
```

### 4. 关于存储过程使用的争议

#### 1. 优点

- 存储过程可以一次编译多次使用
- 可以减少开发工作量
- 存储过程的安全性强
- 可以减少网络传输量
- 良好的封装性

#### 2. 缺点
- 可移植性差。
- 调试困难
- 存储过程的版本管理很困难
- 它不适合高并发的场景

#### 3. 个人建议 ——> 不使用
:::tip 阿里开发规范
- 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。
:::

## 5. 变量

在 MySQL 数据库中，变量分为 系统变量 以及 用户自定义变量

### 1. 系统变量

#### 1. 系统变量分类

变量由系统定义，不是用户定义，属于 `服务器` 层面。启动MySQL服务，生成MySQL服务实例期间，
MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特
征。这些系统变量的值要么是 `编译MySQL时参数` 的默认值，要么是 `配置文件` （例如my.ini等）中的参数
值。大家可以通过网址 [https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html) 查看MySQL文档的系统变量

系统变量分为`全局系统变量`（需要添加 global 关键字）以及`会话系统变量`（需要添加 session 关键
字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，`默认会话级别`。静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量

每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例
会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变
量值的复制

![image](https://cdn.staticaly.com/gh/brook-w/image-hosting@master/mysql/image.21xauovye6rk.jpg)

- 全局系统变量针对于所有会话（连接）有效，但 `不能跨重启`
- 会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值
- 会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改

#### 2. 查看系统变量

**查看所有或部分系统变量**
```sql
#查看所有全局变量 
SHOW GLOBAL VARIABLES; 

#查看所有会话变量 
SHOW SESSION VARIABLES; 
#或
SHOW VARIABLES

#查看满足条件的部分系统变量
SHOW GLOBAL VARIABLES LIKE '%标识符%'; 
#查看满足条件的部分会话变量 
SHOW SESSION VARIABLES LIKE '%标识符%';

SHOW GLOBAL VARIABLES LIKE 'admin_%';
```

**查看指定系统变量**

作为 MySQL 编码规范，MySQL 中的系统变量以 两个 `@` 开头，其中`@@global`仅用于标记全局系统变
量，`@@session` 仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，
则标记全局系统变量。

```sql
#查看指定的系统变量的值 
SELECT @@global.变量名; 
#查看指定的会话变量的值 
SELECT @@session.变量名; 
#或者 
SELECT @@变量名;
```

**修改系统变量的值**

- 方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）
- 方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值

```sql
#为某个系统变量赋值 
#方式1： 
SET @@global.变量名=变量值; 

#方式2： 
SET GLOBAL 变量名=变量值; 

#为某个会话变量赋值 
#方式1： 
SET @@session.变量名=变量值; 
#方式2： 
SET SESSION 变量名=变量值

SELECT @@global.autocommit; 
SET GLOBAL autocommit=0; 

SELECT @@session.tx_isolation; 
SET @@session.tx_isolation='read-uncommitted'; 
SET GLOBAL max_connections = 1000; 

SELECT @@global.max_connections;
```

### 2. 用户变量

#### 1. 用户变量分类

MySQL 中的用户变量以一个 `@` 开头

- 会话用户变量：作用域和会话变量一样，只对 `当前连接` 会话有效。
- 局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在 `存储过程和函数` 中使用。

#### 2. 会话用户变量

```sql
#方式1：“=”或“:=” 
SET @用户变量 = 值; 
SET @用户变量 := 值; 

#方式2：“:=” 或 INTO关键字 
SELECT @用户变量 := 表达式 [FROM 等子句]; 
SELECT 表达式 INTO @用户变量 [FROM 等子句];

-- 查看用户变量的值 （查看、比较、运算等）
SELECT @用户变量

-- 举例
SET @a = 1; 
SELECT @a; 
SELECT @num := COUNT(*) FROM employees; 
SELECT @num; SELECT AVG(salary) INTO @avgsalary FROM employees; 
SELECT @avgsalary; SELECT @big;
```

#### 3. 局部变量

定义：可以使用 `DECLARE` 语句定义一个局部变量

作用域：仅仅在定义它的 BEGIN ... END 中有效

位置：只能放在 BEGIN ... END 中，而且只能放在第一句

```sql
BEGIN
  #声明局部变量 
  DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值]; 
  DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值]; 
  
  #为局部变量赋值 
  SET 变量名1 = 值; 
  SELECT 值 INTO 变量名2 [FROM 子句]; 
  
  #查看局部变量的值 
  SELECT 变量1,变量2,变量3; 
END

-- 定义变量
DECLARE 变量名 类型 [default 值]; # 如果没有DEFAULT子句，初始值为NULL
DECLARE myparam INT DEFAULT 100;

-- 变量赋值
SET 变量名=值; 
SET 变量名:=值;
SELECT 字段名或表达式 INTO 变量名 FROM 表;

-- 使用变量
SELECT 局部变量名;

-- 举例1：声明局部变量，并分别赋值为employees表中employee_id为102的last_name和salary
DELIMITER // 
CREATE PROCEDURE set_value() 
BEGIN
  DECLARE emp_name VARCHAR(25); 
  DECLARE sal DOUBLE(10,2); 
  SELECT last_name,salary INTO emp_name,sal FROM employees WHERE employee_id = 102; 
  SELECT emp_name,sal; 
END // 
DELIMITER ;

-- 举例2：声明两个变量，求和并打印 （分别使用会话用户变量、局部变量的方式实现）
#方式1：使用用户变量 
SET @m=1; 
SET @n=1; 
SET @sum=@m+@n; 

SELECT @sum;

#方式2：使用局部变量 
DELIMITER // 
CREATE PROCEDURE add_value() BEGIN
  #局部变量 
  DECLARE m INT DEFAULT 1; 
  DECLARE n INT DEFAULT 3; 
  DECLARE SUM INT; SET SUM = m+n; 
  SELECT SUM; 
END // 
DELIMITER ;

-- 举例3：创建存储过程“different_salary”查询某员工和他领导的薪资差距，并用IN参数emp_id接收员工id，用OUT参数dif_salary输出薪资差距结果

#声明 
DELIMITER //
CREATE PROCEDURE different_salary(IN emp_id INT,OUT dif_salary DOUBLE) 
BEGIN
  #声明局部变量 
  DECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0; 
  DECLARE mgr_id INT; 
  SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id; 
  SELECT manager_id INTO mgr_id FROM employees WHERE employee_id = emp_id; 
  SELECT salary INTO mgr_sal FROM employees WHERE employee_id = mgr_id;
  SET dif_salary = mgr_sal - emp_sal; 
END // 
DELIMITER ; 

#调用 
SET @emp_id = 102; 
CALL different_salary(@emp_id,@diff_sal); 

#查看 
SELECT @diff_sal;
```

#### 4. 对比会话用户变量与局部变量

| |作用域 |定义位置 | 语法|
|---|---|---|---|
|会话用户变量| 当前会话 |会话的任何地方| 加@符号，不用指定类型|
|局部变量 |定义它的BEGIN END中| BEGIN END的第一句话 |一般不用加@,需要指定类型|

### 3. MySQL 8.0的新特性—全局变量的持久化
在MySQL数据库中，全局变量可以通过`SET GLOBAL`语句来设置。例如，设置服务器语句超时的限制，可
以通过设置系统变量`max_execution_time`来实现:

```sql
SET GLOBAL MAX_EXECUTION_TIME=2000;
```

使用`SET GLOBAL`语句设置的变量值只会 `临时生效` 。 `数据库重启` 后，服务器又会从MySQL配置文件中读取
变量的默认值。 MySQL 8.0版本新增了 `SET PERSIST` 命令。例如，设置服务器的最大连接数为1000：

```sql
SET PERSIST global max_connections = 1000;
```

MySQL会将该命令的配置保存到数据目录下的 `mysqld-auto.cnf` 文件中，下次启动时会读取该文件，用
其中的配置来覆盖默认的配置文件

```sql
-- 举例
# 1. 查看全局变量max_connections的值
show variables like '%max_connections%'; 
+------------------------+-------+
| Variable_name          | Value | 
+------------------------+-------+
| max_connections        | 151   | 
| mysqlx_max_connections | 100   | 
+------------------------+-------+

# 2. 设置全局变量max_connections的值：
set persist max_connections=1000;

# 3. 重启MySQL服务器 ，再次查询max_connections的值：
show variables like '%max_connections%';
+------------------------+-------+
| Variable_name          | Value | 
+------------------------+-------+
| max_connections        | 1000  | 
| mysqlx_max_connections | 100   | 
+------------------------+-------+
```


## 6. 流程控制

解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控
制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程
就分为三大类：

- 顺序结构 ：程序从上往下依次执行
- 分支结构 ：程序按条件进行选择执行，从两条或多条路径中选择一条执行
- 循环结构 ：程序满足一定条件下，重复执行一组语句

针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序

- 条件判断语句 ：IF 语句和 CASE 语句
- 循环语句 ：LOOP、WHILE 和 REPEAT 语句
- 跳转语句 ：ITERATE 和 LEAVE 语句

### 1. 分支结构之 IF

- IF 语句的语法结构是：

```sql
IF 表达式1 THEN 操作1 
[ELSEIF 表达式2 THEN 操作2]…… 
[ELSE 操作N] 
END IF
```

根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的

- 特点：
  - 1. 不同的表达式对应不同的操作
  - 2. 使用在begin end中

```sql
-- 举例1
IF val IS NULL 
  THEN SELECT 'val is null'; 
ELSE SELECT 'val is not null'; 
END IF;

-- 举例2：声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于8000元并且入职时间超过5年，就涨薪500元；否则就不变

DELIMITER // 

CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT) 
BEGIN
  DECLARE emp_salary DOUBLE; 
  DECLARE hire_year DOUBLE; 
  SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id; 
  SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year FROM employees WHERE employee_id = emp_id; 
  IF emp_salary < 8000 AND hire_year > 5 THEN 
    UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id; 
  END IF; 
END // 

DELIMITER ;
-- 举例3：声明存储过程“update_salary_by_eid2”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元并且入职时间超过5年，就涨薪500元；否则就涨薪100元
DELIMITER // 

CREATE PROCEDURE update_salary_by_eid2(IN emp_id INT) BEGIN
  DECLARE emp_salary DOUBLE; 
  DECLARE hire_year DOUBLE; 
  SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id; 
  SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year FROM employees WHERE employee_id = emp_id; 
  IF emp_salary < 8000 AND hire_year > 5 THEN
     UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id; 
  ELSE 
    UPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id; 
  END IF; 
END // 

DELIMITER ;

```

### 2. 分支结构之 CASE

```sql
-- CASE 语句的语法结构1：
#情况一：类似于switch 
CASE 表达式 
WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号) 
WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号) 
... 
ELSE 结果n或语句n(如果是语句，需要加分号) 
END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）

-- CASE 语句的语法结构2：
#情况二：类似于多重if 
CASE 
WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号) 
WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号) 
... 
ELSE 结果n或语句n(如果是语句，需要加分号) 
END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）

-- 举例1:
# 使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。
CASE val 
  WHEN 1 THEN SELECT 'val is 1'; 
  WHEN 2 THEN SELECT 'val is 2'; 
  ELSE SELECT 'val is not 1 or 2'; 
END CASE;

-- 举例2：
# 使用CASE流程控制语句的第2种格式，判断val是否为空、小于0、大于0或者等于0
CASE
WHEN val IS NULL THEN SELECT 'val is null'; 
WHEN val < 0 THEN SELECT 'val is less than 0'; 
WHEN val > 0 THEN SELECT 'val is greater than 0'; 
ELSE SELECT 'val is 0'; 
END CASE;
```

### 3. 循环结构之LOOP

LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程

LOOP语句的基本格式如下：
```sql
[loop_label:] LOOP  # loop_label表示LOOP语句的标注名称,可以省略
  循环执行的语句 
END LOOP [loop_label]

-- 举例1：
# 使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程
DECLARE id INT DEFAULT 0; 
add_loop:LOOP 
  SET id = id +1; 
  IF id >= 10 THEN LEAVE add_loop; 
  END IF; 
END LOOP add_loop;
```
### 4. 循环结构之WHILE

WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如
果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下

```sql
[while_label:] WHILE 循环条件 DO 
  循环体 
END WHILE [while_label]

-- 举例1：
# WHILE语句示例，i值小于10时，将重复执行循环过程

DELIMITER // 

CREATE PROCEDURE test_while() 
BEGIN
  DECLARE i INT DEFAULT 0; WHILE i < 10 DO SET i = i + 1; 
  END WHILE; SELECT i; 
END // 

DELIMITER ; 

#调用 
CALL test_while();
```

### 5. 循环结构之REPEAT
REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循
环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会
就继续执行循环，直到满足退出条件为止

```sql
[repeat_label:] REPEAT 
  循环体的语句 
UNTIL 结束循环的条件表达式 
END REPEAT [repeat_label]

-- 举例1：

DELIMITER // 

CREATE PROCEDURE test_repeat() 
BEGIN
  DECLARE i INT DEFAULT 0; REPEATSET i = i + 1; 
  UNTIL i >= 10 END REPEAT; 
  SELECT i; 
END // 

DELIMITER ;
```

**对比三种循环结构**

- 1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称 
- 2、 LOOP：一般用于实现简单的"死"循环 WHILE：先判断后执行 REPEAT：先执行后判断，无条件至少执行一次

### 6. 跳转语句之LEAVE语句

LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出
程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break

```sql
LEAVE 标记名

-- 举例：当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明OUT参数num，输出循环次数，存储过程中使用WHILE循环给大家降低薪资为原来薪资的90%，直到全公司的平均薪资小于等于10000，并统计循环次数

DELIMITER // 

CREATE PROCEDURE leave_while(OUT num INT) 
BEGIN

  DECLARE avg_sal DOUBLE;#记录平均工资
  DECLARE while_count INT DEFAULT 0; #记录循环次数 

  SELECT AVG(salary) INTO avg_sal FROM employees; #① 初始化条件 

  while_label:WHILE TRUE DO #② 循环条件 

    #③ 循环体 
    IF avg_sal <= 10000 THEN 
      LEAVE while_label; 
    END IF; 

    UPDATE employees SET salary = salary * 0.9; 
    SET while_count = while_count + 1; 

    #④ 迭代条件 
    SELECT AVG(salary) INTO avg_sal FROM employees; 
    
  END WHILE; 

  #赋值 SET num = while_count; 
END // 

DELIMITER ;  
```

### 7. 跳转语句之ITERATE语句

ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序
转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意
思为"再次循环"

```sql
ITERATE label

-- 举例： 定义局部变量num，初始值为0。循环结构中执行num + 1操作。
--  如果num < 10，则继续执行循环；
--  如果num > 15，则退出循环结构；

DELIMITER // 

CREATE PROCEDURE test_iterate() 
BEGIN
  DECLARE num INT DEFAULT 0; 
  my_loop:LOOP SET num = num + 1; 
    IF num < 10 THEN 
      ITERATE my_loop; 
    ELSEIF num > 15 THEN 
      LEAVE my_loop;
    END IF;
    SELECT '尚硅谷：让天下没有难学的技术';
  END LOOP my_loop;
END // 

DELIMITER ;
```

## 7. 游标

### 1. 什么是游标（或光标）

虽然我们也可以通过筛选条件 `WHERE` 和 `HAVING`，或者是限定返回记录的关键字 `LIMIT` 返回一条记录，
但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是 `随意定位到某一` 条记录 ，并对记录的数据进行处理

这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录
进行定位，并对指向的记录中的数据进行操作的数据结构。`游标让 SQL 这种面向集合的语言有了面向过程开发的能力`

在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标 `充当了指针的作用` ，我们可以通过操作游标来对数据行进行操作

MySQL中游标可以在存储过程和函数中使用

### 2. 使用游标步骤

#### 1. 声明游标



```sql
-- 在MySQL中，使用`DECLARE`关键字来声明游标,这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB
DECLARE cursor_name CURSOR FOR select_statement;

-- 如果是用 Oracle 或者 PostgreSQL
DECLARE cursor_name CURSOR IS select_statement;
```

要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 `select_statement` 代表的是
SELECT 语句，返回一个用于创建游标的结果集

```sql
DECLARE cur_emp CURSOR FOR SELECT employee_id,salary FROM employees; 
DECLARE cursor_fruit CURSOR FOR SELECT f_name, f_price FROM fruits ;
```

#### 2. 打开游标

```sql
OPEN cursor_name
OPEN cur_emp ;
```

#### 3. 使用游标（从游标中取得数据）

```sql
# 使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可
FETCH cursor_name INTO var_name [, var_name] ...

FETCH cur_emp INTO emp_id, emp_sal ; # 游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致
```

#### 4. 关闭游标

```sql
CLOSE cursor_name # 游标会一直保持到存储过程结束，必须要关闭
CLOSE cur_emp;
```

### 3. 举例

创建存储过程`get_count_by_limit_total_salary()`，声明IN参数 limit_total_salary，DOUBLE类型；声明
OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和
达到limit_total_salary参数的值，返回累加的人数给total_count

```sql
DELIMITER // 

CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT total_count INT) 
BEGIN
  DECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资 
  DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值 
  DECLARE emp_count INT DEFAULT 0; #记录循环个数 #定义游标 
  DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC; 

  #打开游标 
  OPEN emp_cursor; REPEAT

  #使用游标（从游标中获取数据） 
  FETCH emp_cursor INTO cursor_salary; 
  SET sum_salary = sum_salary + cursor_salary; 
  SET emp_count = emp_count + 1; 
  UNTIL sum_salary >= limit_total_salary END REPEAT; 
  SET total_count = emp_count; 
  
  #关闭游标 
  CLOSE emp_cursor;
  END // 
  
DELIMITER ;
```

### 4. 小结

游标是 MySQL 的一个重要的功能，为 `逐条读取` 结果集中的数据，提供了完美的解决方案。跟在应用层
面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。

但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行 `加锁` ，这样在业务并发量大
的时候，不仅会影响业务之间的效率，还会 `消耗系统资源` ，造成`内存不足`，这是因为游标是在内存中进
行的处理。

建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率


## 8. 定义条件与处理程序

- `定义条件` 是事先定义程序执行过程中可能遇到的问题，
- `处理程序` 定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。
- 说明：定义条件和处理程序在存储过程、存储函数中都是支持的

### 1. 案例分析

创建一个名称为 `UpdateDataNoCondition` 的存储过程

```sql

DELIMITER // 

CREATE PROCEDURE UpdateDataNoCondition() 
BEGIN
  SET @x = 1; 
  UPDATE employees SET email = NULL WHERE last_name = 'Abel'; 
  SET @x = 2; 
  UPDATE employees SET email = 'aabbel' WHERE last_name = 'Abel'; 
  SET @x = 3; 
END // 

DELIMITER ;
```

调用存储过程：

```sql
CALL UpdateDataNoCondition();
ERROR 1048 (23000): Column 'email' cannot be null

SELECT @x;
+------+
| @x   | 
+------+
| 1    | 
+------+
```

可以看到，此时@x变量的值为1。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件
和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑，
不再向下继续执行

### 2. 定义条件

定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个 `错误名字` 和 指定的 `错误条件` 关联起来。这个名字可以随后被用在定义处理程序的` DECLARE HANDLER` 语句中

```sql
DECLARE 错误名称 CONDITION FOR 错误码（或错误条件）
```

错误码的说明：

- `MySQL_error_code` 和 `sqlstate_value` 都可以表示MySQL的错误
  - `MySQL_error_code` 是数值类型错误代码
  - `sqlstate_value` 是长度为5的字符串类型错误代码
  - 例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，'HY000'是sqlstate_value。
  - 例如，在ERROR 1142（42000）中，1142是MySQL_error_code，'42000'是sqlstate_value。

- 举例1：定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR 1048 (23000)”对
应

```sql
#使用MySQL_error_code 
DECLARE Field_Not_Be_NULL CONDITION FOR 1048; 

#使用sqlstate_value 
DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE '23000';
```

- 举例2：定义"ERROR 1148(42000)"错误，名称为command_not_allowed

```sql
#使用MySQL_error_code 
DECLARE command_not_allowed CONDITION FOR 1148; 

#使用sqlstate_value 
DECLARE command_not_allowed CONDITION FOR SQLSTATE '42000';
```

### 3. 定义处理程序

可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序

```sql
DECLARE 处理方式 HANDLER FOR 错误类型 处理语句
```


- 处理方式：处理方式有3个取值：CONTINUE、EXIT、UNDO。 
  - CONTINUE ：表示遇到错误不处理，继续执行。
  - EXIT ：表示遇到错误马上退出。
  - UNDO ：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。
- 错误类型（即条件）可以有如下取值：
  - SQLSTATE '字符串错误码' ：表示长度为5的sqlstate_value类型的错误代码； 
  - MySQL_error_code ：匹配数值类型-错误代码；
  - 错误名称 ：表示DECLARE ... CONDITION定义的错误条件名称。
  - SQLWARNING ：匹配所有以01开头的SQLSTATE错误代码；
  - NOT FOUND ：匹配所有以02开头的SQLSTATE错误代码；
  - SQLEXCEPTION ：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；
处理语句：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像“ SET 变量 = 值 ”这样的简单语句，也可以是使用 BEGIN ... END 编写的复合语句

```sql
#方法1：捕获sqlstate_value 
DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02' SET @info = 'NO_SUCH_TABLE'; 

#方法2：捕获mysql_error_value 
DECLARE CONTINUE HANDLER FOR 1146 SET @info = 'NO_SUCH_TABLE'; 

#方法3：先定义条件，再调用 
DECLARE no_such_table CONDITION FOR 1146; DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = 'NO_SUCH_TABLE'; 

#方法4：使用SQLWARNING 
DECLARE EXIT HANDLER FOR SQLWARNING SET @info = 'ERROR'; 

#方法5：使用NOT FOUND 
DECLARE EXIT HANDLER FOR NOT FOUND SET @info = 'NO_SUCH_TABLE'; 

#方法6：使用SQLEXCEPTION 
DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = 'ERROR';
```

### 4. 案例解决

在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为1048时，执行
CONTINUE操作，并且将@proc_value的值设置为-1

```sql
DELIMITER // 

CREATE PROCEDURE UpdateDataNoCondition() 
BEGIN
  #定义处理程序 
  DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1; 
  SET @x = 1;
  UPDATE employees SET email = NULL WHERE last_name = 'Abel'; 
  SET @x = 2; 
  UPDATE employees SET email = 'aabbel' WHERE last_name = 'Abel'; 
  SET @x = 3;
  END //

DELIMITER ;
```

```sql
CALL UpdateDataWithCondition();

SELECT @x,@proc_value;
+------+-------------+
| @x   | @proc_value | 
+------+-------------+
| 3    | -1          | 
+------+-------------+
```

举例：
创建一个名称为“InsertDataWithCondition”的存储过程

在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000时，执行EXIT操
作，并且将@proc_value的值设置为-1

```sql
#准备工作 
CREATE TABLE departments ASSELECT * FROM atguigudb.`departments`; 
ALTER TABLE departments ADD CONSTRAINT uk_dept_name UNIQUE(department_id); 

DELIMITER // 

CREATE PROCEDURE InsertDataWithCondition() 
BEGIN
  DECLARE duplicate_entry CONDITION FOR SQLSTATE '23000' ; 
  DECLARE EXIT HANDLER FOR duplicate_entry SET @proc_value = -1; 
  SET @x = 1; 
  INSERT INTO departments(department_name) VALUES('测试'); 
  SET @x = 2; INSERT INTO departments(department_name) VALUES('测试'); SET @x = 3; 
  END // 
  
DELIMITER ;


# 调用存储过程：

CALL InsertDataWithCondition();

SELECT @x,@proc_value;
+------+-------------+
| @x   | @proc_value | 
+------+-------------+
| 2    | -1          | 
+------+-------------+
```